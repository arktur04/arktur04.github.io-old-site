<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Cortex M3 | Записная книжка разработчика]]></title>
  <link href="http://arktur04.github.io/blog/categories/cortex-m3/atom.xml" rel="self"/>
  <link href="http://arktur04.github.io/"/>
  <updated>2016-02-28T22:14:13+05:00</updated>
  <id>http://arktur04.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Интерфейс прибора]]></title>
    <link href="http://arktur04.github.io/blog/2010/12/12/%25d0%25b8%25d0%25bd%25d1%2582%25d0%25b5%25d1%2580%25d1%2584%25d0%25b5%25d0%25b9%25d1%2581-%25d0%25bf%25d1%2580%25d0%25b8%25d0%25b1%25d0%25be%25d1%2580%25d0%25b0/"/>
    <updated>2010-12-12T15:11:37+05:00</updated>
    <id>http://arktur04.github.io/blog/2010/12/12/%d0%b8%d0%bd%d1%82%d0%b5%d1%80%d1%84%d0%b5%d0%b9%d1%81-%d0%bf%d1%80%d0%b8%d0%b1%d0%be%d1%80%d0%b0</id>
    <content type="html"><![CDATA[<p>Интерфейс прибора реализован на базе монохромного индикатора разрешением 128х64, и включает в себя 35 различных экранов, в которых выполняются все манипуляции с прибором, включая его наладку и тестирование всех узлов (ЦАП, АЦП, все дискретные входы и выходы), установку параметров алгоритма обработки сигналов (DSP), а также все переменные настройки прибора (более 200 переменных).</p>
<p>Программно интерфейс реализован в виде библиотеки классов C++, представляющих элементы управления (кнопки, поля ввода, текстовые поля и пр.)</p>
<p><a href="/images/2010/12/main.png"><img class="alignnone size-full wp-image-938" title="main" src="/assets/main.png" alt="" width="256" height="128" /></a></p>
<p><a href="/images/2010/12/ethernet.png"><img class="alignnone size-full wp-image-939" title="ethernet" src="/assets/ethernet.png" alt="" width="256" height="128" /></a></p>
<p>Так это выглядит в натуральном виде:</p>
<p><a href="/images/2010/12/mainscr.gif"><img class="alignnone size-medium wp-image-946" title="mainscr" src="/assets/mainscr-300x213.gif" alt="" width="300" height="213" /></a></p>
<p>Ещё  несколько картинок под катом.</p>
<p><!--more--><a href="/images/2010/12/menu1.png"><img class="alignnone size-full wp-image-940" title="menu1" src="/assets/menu1.png" alt="" width="256" height="128" /></a></p>
<p><a href="/images/2010/12/param1.png"><img class="alignnone size-full wp-image-941" title="param1" src="/assets/param1.png" alt="" width="256" height="128" /></a></p>
<p><a href="/images/2010/12/rs485.png"><img class="alignnone size-full wp-image-942" title="rs485" src="/assets/rs485.png" alt="" width="256" height="128" /></a></p>
<p><a href="/images/2010/12/test_ai.png"><img class="alignnone size-full wp-image-943" title="test_ai" src="/assets/test_ai.png" alt="" width="256" height="128" /></a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Прерывания в Cortex M3. Часть 3]]></title>
    <link href="http://arktur04.github.io/blog/2010/11/19/%25d0%25bf%25d1%2580%25d0%25b5%25d1%2580%25d1%258b%25d0%25b2%25d0%25b0%25d0%25bd%25d0%25b8%25d1%258f-%25d0%25b2-cortex-m3-%25d1%2587%25d0%25b0%25d1%2581%25d1%2582%25d1%258c-3/"/>
    <updated>2010-11-19T06:56:24+05:00</updated>
    <id>http://arktur04.github.io/blog/2010/11/19/%d0%bf%d1%80%d0%b5%d1%80%d1%8b%d0%b2%d0%b0%d0%bd%d0%b8%d1%8f-%d0%b2-cortex-m3-%d1%87%d0%b0%d1%81%d1%82%d1%8c-3</id>
    <content type="html"><![CDATA[<p>В предыдущей части (<a href="http://32bit.me/?p=842">http://32bit.me/?p=842</a>) были рассмотрены основные функции работы с прерываниями микроконтроллера LPC17хх. Однако, рассмотренные функции не работают с особым видом прерываний ядра Cortex M3 - системными исключениями. Ниже будет рассмотрена работа с системными исключениями на примере системного исключения SysTick. Также будет рассмотрено одно исключение из тех правил работы с прерываниями, которые рассматривались в части 2.</p>
<p><!--more-->Адреса обработчиков системных исключений находятся там же, где и адреса обработчиков прерываний, а именно в таблице адресов прерываний, находящейся в проектах IAR в файле cstartup_M.s. Оттуда можно скопировать имя функции обработчика нужного прерывания и вставить его в проект. Для обработчика системного исключения таймера SysTick заголовок функции-обработчика будет выглядеть так:</p>
<pre lang="c">void SysTick_Handler(void)</pre>
<p>Для обеспечения корректной работы обработчика необходимо , как минимум, назначить системному исключению приоритет и сбросить его в неактивное состояние после обработки (т.е., всё так же, как и у обычного прерывания). Но приоритеты системных исключений назначаются не в регистрах NVIC, а в регистрах системного блока управления (System control block), которые называются SHPR1 - SHPR3 (для разнообразия, они нумеруются, начиная с 1, а не с 0, т.е. регистра SHPR0 не существует). Приоритет системного исключения SysTick задаётся в регистре SHPR3, в битах [31:24]. Адрес регистра SHPR3 равен 0xE000ED20, и мы можем записать:</p>
<pre lang="c">unsigned long  * pSHPR3 = (unsigned long *)0xE000ED20;

* pSHPR3 = SYS_TICK_PRIORITY &lt;&lt; 24;</pre>
<p>Сброс прерывания SysTick в неактивное состояние осуществляется с помощью регистра ICSR того же системного блока управления.</p>
<p>Обработчик системного исключения SysTick выглядит так:</p>
<pre lang="c">void SysTick_Handler(void)
{
//тело обработчика

//...

//сброс прерывания
ICSR_bit.PENDSTCLR = 1;
}</pre>
<p>И, в заключение, ещё одна особенность, на этот раз связанная с обработкой прерывания Repetitive Interrupt Handler. У этого прерывания сброс в неактивное состояние нужно выполнять так:</p>
<pre lang="c">RICTRL_bit.RITINT = 1;</pre>
<p>Здесь RICTRL - регистр управления самого таймера RIT. Сброс прерывания в контроллере NVIC выполнится при этом автоматически.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Прерывания в Cortex M3. Часть 2]]></title>
    <link href="http://arktur04.github.io/blog/2010/11/17/%25d0%25bf%25d1%2580%25d0%25b5%25d1%2580%25d1%258b%25d0%25b2%25d0%25b0%25d0%25bd%25d0%25b8%25d1%258f-%25d0%25b2-cortex-m3-%25d1%2587%25d0%25b0%25d1%2581%25d1%2582%25d1%258c-2/"/>
    <updated>2010-11-17T20:19:09+05:00</updated>
    <id>http://arktur04.github.io/blog/2010/11/17/%d0%bf%d1%80%d0%b5%d1%80%d1%8b%d0%b2%d0%b0%d0%bd%d0%b8%d1%8f-%d0%b2-cortex-m3-%d1%87%d0%b0%d1%81%d1%82%d1%8c-2</id>
    <content type="html"><![CDATA[<p>В первой части (<a href="http://32bit.me/?p=839">http://32bit.me/?p=839</a>) были приведены некоторые сведения о структуре контроллера прерываний Cortex M3. В этой части будут рассматриваться примеры обработки прерываний в этой архитектуре.</p>
<p><!--more-->Обработка большинства прерываний происходит следующим образом: в файле cstartup_M.s находится таблица векторов прерываний следующего вида:</p>
<pre lang="c" line="1">
__vector_table_0x1c
DCD     0                           ; Reserved
DCD     0                           ; Reserved
DCD     0                           ; Reserved
DCD     0                           ; Reserved
DCD     SVC_Handler                 ; SVCall Handler
DCD     DebugMon_Handler            ; Debug Monitor Handler
DCD     0                           ; Reserved
DCD     PendSV_Handler              ; PendSV Handler
DCD     SysTick_Handler             ; SysTick Handler
DCD     WDT_IRQHandler              ; Watchdog Handler
DCD     TMR0_IRQHandler             ; TIMER0 Handler
DCD     TMR1_IRQHandler             ; TIMER1 Handler
</pre>
<p>Она устанавливает связь между самим прерыванием и его обработчиком. По умолчанию все обработчики установлены в Default_Handler, эта команда приводит к останову программы. Для того, чтобы задействовать свой обработчик прерывания, нужно скопировать из cstartup_M.s нужное имя функции, например:</p>
<pre lang="c" line="1">
void TMR0_IRQHandler(void)
{
//тело обработчика
}
</pre>
<p>Но, для того, чтобы обработчик работал правильно, нужно сделать ещё две вещи: присвоить прерыванию приоритет и в теле обработчика снять флаг обработки прерывания. Последнее действие информирует контроллер прерывания, что данное прерывание уже обработано.</p>
<p>Итак, приоритет прерывания устанавливается следующим образом:</p>
<pre lang="c" line="1">
void NVIC_IntPri(Int32U IntNumber, Int8U Priority)
{
//pNVIC - указатель на таблицу приоритетов прерываний.
volatile Int8U * pNVIC_IntPri = (Int8U *)&IP0;
//проверка того, что номер прерывания не выходит за пределы таблицы
assert((NVIC_WDT &lt; IntNumber) &amp;&amp; (NVIC_PLL1 &gt;= IntNumber));
//получаем смещение в таблице
IntNumber -= NVIC_WDT;
//получаем указатель на регистр приоритета прерывания
pNVIC_IntPri += IntNumber;
// устанавливаем приоритет
*pNVIC_IntPri = Priority;
}</pre>
<p>В рассмотренном коде наибольшие затруднения может вызвать действие IntNumber -= NVIC_WDT. Проясним его смысл. Дело в том, что формально таблица прерываний начинаются именно с прерывания NVIC_WDT. Всё, что находится выше NVIC_WDT, считается не прерыванием, а системным исключением. NVIC_WDT имеет в таблице прерываний 16-й номер, однако в таблице приоритетов прерываний оно имеет номер 0. Чтобы получить из номера прерывания смещение в таблице приоритетов, мы должны из номера прерывания вычесть значение NVIC_WDT. Дальнейшие действия понятны: мы прибавляем смещение в таблице к адресу самой таблицы приоритетов и в полученный регистр записываем значение приоритета прерывания.  Так как регистры приоритета имеют разрядность 8 бит, все операции с адресами здесь производятся с указателями на байты (Int8U *).</p>
<p>По умолчанию все прерывания имеют приоритет 0 (самый высокий).</p>
<p>Однако, для корректной работы обработчика требуется сообщить контроллеру прерываний, что прерывание обработано, для того, чтобы снять флаг "отложено" (pending). Делается это с помощью аналогичной функции:</p>
<pre lang="c" line="1">void NVIC_ClrPend(Int32U IntNumber)
{
//pNVIC - указатель на таблицу Interrupt Clear-Pending Register
volatile unsigned long * pNVIC_ClrPend = &CLRPEND0;
//проверка того, что номер прерывания не выходит за пределы таблицы
assert((NVIC_WDT &lt;= IntNumber) &amp;&amp; (NVIC_PLL1 &gt;= IntNumber));
//получаем смещение в таблице
IntNumber -= NVIC_WDT;
//получаем указатель на нужный регистр
//сейчас регистры 32-битные,
//флаг очистки каждого прерывания занимает 1 бит
//поэтому номер прерывания делим на 32
pNVIC_ClrPend += IntNumber/32;
*pNVIC_ClrPend = (1UL&lt;&lt;(IntNumber%32));
}
</pre>
<p>Как видно из приведённого кода, он аналогичен коду функции установки приоритета прерывания, за исключением следующих особенностей: указатель вычисляется  в 32-битной арифметике, поэтому мы здесь оперируем с типом (unsigned long*), указатель pNVIC расположен по базовому адресу ICPR0 (Interrupt Clear-Pending Register 0), и номер прерывания делим на 32, так как в каждом регистре находятся флаги 32-х прерываний.</p>
<p>Этот код обязательно должен находиться в конце каждого обработчика прерывания (но у этого правила есть исключение, которое будет рассмотрено ниже).</p>
<p>В случае, если логика работы программы требует запрета и разрешения прерываний, то и эти операции производятся аналогично.<br />
Разрешение прерывания:</p>
<pre lang="c" line="1">
void NVIC_IntEnable(Int32U IntNumber)
{
volatile unsigned long * pNVIC_SetEn = &SETENA0;

assert((NVIC_WDT &lt;= IntNumber) &amp;&amp; (NVIC_PLL1 &gt;= IntNumber));
IntNumber -= NVIC_WDT;

pNVIC_SetEn += IntNumber/32;
*pNVIC_SetEn = (1UL &lt;&lt; (IntNumber%32));
}
</pre>
<p>Запрет прерывания:</p>
<pre lang="c" line="1">
void NVIC_IntDisable(Int32U IntNumber)
{
volatile unsigned long * pNVIC_ClrEn = &amp; CLRENA0;

assert((NVIC_WDT &lt;= IntNumber) &amp;&amp; (NVIC_PLL1 &gt;= IntNumber));
IntNumber -= NVIC_WDT;

pNVIC_ClrEn += IntNumber/32;
*pNVIC_ClrEn = (1UL &lt;&lt; (IntNumber%32));
}
</pre>
<p>Ранее говорилось о том, что системные исключения располагаются в таблице векторов прерываний выше, чем NVIC_WDT. Однако, приведённые функции работают только с прерываниями, начиная с NVIC_WDT. В самом деле, для работы с системными прерываниями нужны другие функции.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Прерывания в Cortex M3. Часть 1]]></title>
    <link href="http://arktur04.github.io/blog/2010/11/12/%25d0%25bf%25d1%2580%25d0%25b5%25d1%2580%25d1%258b%25d0%25b2%25d0%25b0%25d0%25bd%25d0%25b8%25d1%258f-%25d0%25b2-cortex-m3-%25d1%2587%25d0%25b0%25d1%2581%25d1%2582%25d1%258c-1/"/>
    <updated>2010-11-12T23:31:52+05:00</updated>
    <id>http://arktur04.github.io/blog/2010/11/12/%d0%bf%d1%80%d0%b5%d1%80%d1%8b%d0%b2%d0%b0%d0%bd%d0%b8%d1%8f-%d0%b2-cortex-m3-%d1%87%d0%b0%d1%81%d1%82%d1%8c-1</id>
    <content type="html"><![CDATA[<p>По сравнению с микроконтроллерами ARM7, такими как LPC2368, в архитектуре Cortex M3 наибольшей модернизации подверглась система прерываний. Она стала существенно более сложной и гибкой. Ниже будут рассмотрены некоторые особенности нового контроллера прерываний (Nested Vectored Interrupt Controller, NVIC).</p>
<p><strong><!--more-->Общие сведения</strong> о NVIC таковы:</p>
<ul>
<li> поддержка 35 векторных прерываний (в LPC17xx), всего ядро Cortex M3 может поддерживать до 112 прерываний</li>
<li>поддержка как прерываний от периферии, так и системных исключений</li>
<li> 32 программируемых уровней приоритета с возможностью маскирования</li>
<li> перемещаемая таблица векторов</li>
<li> поддержка программного прерывания</li>
</ul>
<p>Также NVIC поддерживает одно немаскируемое прерывание (NMI) от входа P2.10/NMI.</p>
<p>Прерывания пронумерованы от 0 до 34, и включают в себя прерывания от таймеров, UART, внешние прерывания, а также прерывания от других периферийных устройств.</p>
<p>Каждое прерывание может находится в одном из 4-х состояний:</p>
<ul>
<li>Неактивное/Inactive</li>
<li>Отложенное/Pending</li>
<li>Активное/Active</li>
<li>Активное и отложенное/Active and pending (состояние возникает, когда во время обработки прерывания наступило прерывание от того же источника).</li>
</ul>
<p>Контроллер прерываний включает в себя следующие регистры:</p>
<p>ISER0, ISER1 - Interrupt Set-Enable Registers</p>
<p>ICER0-ICER1 - Interrupt Clear-Enable Registers</p>
<p>ISPR0-ISPR1 - Interrupt Set-Pending Registers</p>
<p>ICPR0-ICPR1 - Interrupt Clear-Pending Registers</p>
<p>IABR0-IABR1 - Interrupt Active Bit Registers</p>
<p>IPR0 - IPR8 - Interrupt Priority Registers (каждый регистр приоритета содержит 5-битные поля приоритета для 4-х прерываний)</p>
<p>STIR - Software Trigger Interrupt Registers</p>
<p>Подробное описание регистров NVIC приведено в документации на микроконтроллер.</p>
<p><strong>Исключения (Exception)</strong></p>
<p>Каждое прерывание является исключением, однако не каждое исключение является прерыванием. Помимо обычных прерываний, имеются системные исключения. Одно из таких исключений, SysTick, было рассмотрено здесь: <a href="http://32bit.me/?p=796">http://32bit.me/?p=796</a>. Системные исключения не входят в число 35 прерываний, которыми мы можем управлять через регистры NVIC, управление ими происходит через другие регистры, такие как System Handler Priority Registers (SHPR1 - SHPR3). Системные исключения также имеют приоритеты, однако у некоторых из них приоритеты фиксированы и <em>имеют отрицательные значения</em>. Это означает, что никакое прерывание с программируемым приоритетом не может иметь более высокий приоритет, чем прерывание с фиксированным отрицательным приоритетом.</p>
<p>Однако никакой принципиальной разницы между прерываниями и системными исключениями нет.</p>
<p><strong>Группирование прерываний по приоритетам</strong></p>
<p>Самой интересной особенностью NVIC в Cortex M3 является возможность группирования прерываний по приоритетам.</p>
<p>Что это такое? Каждому прерыванию может быть назначен приоритет и субприоритет. Допустим, у нас задействованы 4 прерывания таймеров: TIMER0-TIMER3, которым назначены следующие приоритеты и субприоритеты (обозначим их как P и S соответственно):</p>
<p>TIMER0 - P = 0, S = 0</p>
<p>TIMER1 - P = 1, S = 0</p>
<p>TIMER2 - P = 1, S = 1</p>
<p>TIMER3 - P = 2 S = 0</p>
<p>Высшим приоритетом является нулевой, чем больше номер приоритета, тем приоритет ниже. Субприоритеты нумеруются аналогично: высшим субприоритетом является нулевой.</p>
<p>Прерывания подчиняются следующим правилам:</p>
<p>Прерывания с высшим приоритетом всегда прерывает обработку прерывания с более низким приоритетом. В рассмотренном примере прерывание TIMER0 прервёт обработку TIMER2, но TIMER1 не прервёт обработку TIMER2, так как они имеют одинаковый приоритет. Номер субприоритета при этом не имеет значения.</p>
<p>Если выполняется обработка TIMER0, и в это время возникают прерывания TIMER1, TIMER2 и TIMER3, то их выполнение откладывается (pending). По окончании обработки TIMER0 контроллер прерываний начинает выполнение одного из отложенных прерываний, исходя из его приоритета и субприоритета. В рассмотренном примере после выполнения обработки TIMER0 отложенные прерывания будут выполняться в следующем порядке: TIMER1, TIMER2 и TIMER3.</p>
<p>Выше упоминалось о том, что приоритет задаётся 5-битным полем в регистрах IPR0 - IPR8. Как задаётся субприоритет?</p>
<p>Приоритет и субприоритет задаются в одном и том же 5-битном поле, при этом количество бит, отводимых на номер субприоритета задаётся программно в регистре AIRCR (Application Interrupt and Reset Control Register). Трёхбитовое поле PRIGROUP этого регистра определяет, сколько бит в поле приоритета будет отводиться под субприоритет (от 0 до 5). Для записи в этот регистр его необходимо "отпереть" ключом, записав в поле VECTKEYSTAT "магическое" число 0x5FA.</p>
<p>Подробная информация по прерываниям и исключениям приведена в [1]: Chapter 34: Appendix: Cortex-M3 User Guide/3.3 Exception model</p>
<p>Описание NVIC приведено в [1]: Chapter 6: LPC17xx Nested Vectored Interrupt Controller (NVIC)</p>
<p><strong>Литература:</strong></p>
<p>1. UM10360. LPC17xx User Manual. Rev 01 — 4 January 2010.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Repetitive Interrupt Timer]]></title>
    <link href="http://arktur04.github.io/blog/2010/11/11/repetitive-interrupt-timer/"/>
    <updated>2010-11-11T22:47:32+05:00</updated>
    <id>http://arktur04.github.io/blog/2010/11/11/repetitive-interrupt-timer</id>
    <content type="html"><![CDATA[<p>Repetitive Interrupt Timer (RIT) является ещё одним таймером, которого не было в ARM7, и который появился в Cortex M3. Как следует из названия, он предназначен для генерации прерываний, повторяющихся через определённые промежутки времени. Его структура намного проще, чем у обычного таймера-счётчика, но несколько сложнее, чем у SysTick, рассмотренного здесь: <a href="http://32bit.me/?p=796">http://32bit.me/?p=796</a>. В большинстве практических случаев эти таймеры взаимозаменяемы.<br />
Ниже будет рассмотрено применение таймера RIT.</p>
<p><!--more-->Итак, RIT содержит 4 регистра:<br />
RICOMPVAL - в этом регистре должно быть записано значение, с которым производится сравнение значения счётчика.<br />
RIMASK - в этом регистре записывается значение маски, которая применяется к результату сравнения. По умолчанию равен 0. Практическая польза от применения этого регистра неочевидна, поэтому оставим его в нулевом состоянии.<br />
RICTRL - регистр управления. Содержит следующие биты:</p>
<ul>
<li>RITINT - флаг прерывания. Нужен в обработчике прерывания.</li>
<li>RITENCLR -1 означает, что таймер будет обнуляться по достижении совпадения RICOUNTER и RICOMPVAL. Начальное значение 0. Для генерации периодических прерываний должен быть 1.</li>
<li>RITENBR - 1 в этом разряде означает, что таймер будет останавливаться, когда микроконтроллер остановлен в отладчике. Значение по умолчанию: 1</li>
<li>RITEN - 1 - работа таймера разрешена.  Значение по умолчанию: 1</li>
</ul>
<p>RICOUNTER - собственно счётчик. Значение после сброса: 0, запись в этот регистр, как правило, не требуется (хотя возможна).</p>
<p>Таймер тактируется периферийной тактовой частотой (PCLK).</p>
<p>Пусть нам нужно получить прерывание, возникающее периодически с частотой 10 кГц, а тактовая частота микроконтроллера cclk = 100 МГц, периферийная тактовая частота pclk = cclk/4 = 25 МГц.</p>
<p>Инициализация таймера RIT в этом случае выглядит так:</p>
<pre lang="c" line="1">void InitRepetitiveTimer(void)
{
  PCONP_bit.PCRIT = 1; // включаем тактирование и питание
  RICOMPVAL = 2500;//25МГц/10кГц = 2500
  RICTRL_bit.RITENCLR = 1;
  RICTRL_bit.RITENBR  = 1;
  RICTRL_bit.RITEN    = 1;
}
</pre>
<p>Обработчик прерывания:</p>
<pre lang="c" line="1">void RIT_IRQHandler(void)
{
  //сообщаем контроллеру прерываний, что прерывание обрабатывается
  RICTRL_bit.RITINT = 1;
  //...do something
}
</pre>
<p>Из приведённого кода видно, что прерывание снимается с обработки другим способом, чем прерывание SysTick или Timer0-3. Обычно для этой цели используется функция, которая может выглядеть, например, так:</p>
<pre lang="c" line="1">void NVIC_ClrPend(Int32U IntNumber)
{
  volatile unsigned long * pNVIC_ClrPend = &CLRPEND0;

  assert((NVIC_WDT &lt;= IntNumber) &amp;&amp; (NVIC_PLL1 &gt;= IntNumber));
  IntNumber -= NVIC_WDT;
  pNVIC_ClrPend += IntNumber/32;
  *pNVIC_ClrPend = (1UL&lt;&lt;(IntNumber%32));
}
</pre>
<p>Однако в данном случае достаточно всего лишь установить бит RITINT регистра RICTRL в 1, этого достаточно для сброса прерывания.</p>
<p>Полное описание таймера Repetitive Interrupt Timer приведено в [1], в разделе "Chapter 22: LPC17xx Repetitive Interrupt Timer (RIT)"</p>
<p><strong>Литература:</strong></p>
<p>1. UM10360. LPC17xx User Manual. Rev 01 — 4 January 2010.</p>
]]></content>
  </entry>
  
</feed>
