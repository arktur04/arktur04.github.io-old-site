<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: фото | Записная книжка разработчика]]></title>
  <link href="http://arktur04.github.io/blog/categories/foto/atom.xml" rel="self"/>
  <link href="http://arktur04.github.io/"/>
  <updated>2016-02-28T21:56:05+05:00</updated>
  <id>http://arktur04.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Проект видеоадаптера. Часть 2]]></title>
    <link href="http://arktur04.github.io/blog/2015/11/05/vga-%25d0%25b0%25d0%25b4%25d0%25b0%25d0%25bf%25d1%2582%25d0%25b5%25d1%2580-%25d0%25bd%25d0%25b0-fpga/"/>
    <updated>2015-11-05T21:38:06+05:00</updated>
    <id>http://arktur04.github.io/blog/2015/11/05/vga-%d0%b0%d0%b4%d0%b0%d0%bf%d1%82%d0%b5%d1%80-%d0%bd%d0%b0-fpga</id>
    <content type="html"><![CDATA[<p>Продолжение. <a title="Начало" href="http://arktur04.github.io/blog/2015/05/13/%25d0%25bf%25d1%2580%25d0%25be%25d0%25b5%25d0%25ba%25d1%2582-%25d0%25b2%25d0%25b8%25d0%25b4%25d0%25b5%25d0%25be%25d0%25b0%25d0%25b4%25d0%25b0%25d0%25bf%25d1%2582%25d0%25b5%25d1%2580%25d0%25b0-%25d1%2587%25d0%25b0%25d1%2581%25d1%2582%25d1%258c-1/">Начало</a>.</p>
<p>Проект видеоадаптера переделан под использование видео ЦАП ADV7123. Схема подключения приведена на рисунке:</p>
<p><a href="/images/2015/11/VGA_DAC.jpg"><img class="alignnone size-medium wp-image-2168" alt="VGA_DAC" src="/assets/VGA_DAC-300x190.jpg" width="300" height="190" /></a></p>
<p>(по клику откроется полный размер).</p>
<p>Код проекта приведён на гитхабе (<a href="https://github.com/arktur04/VideoCard">ссылка</a>). Это тестовый код, который выводит на монитор поле разноцветных квадратов.</p>
<p>По сравнению с предыдущей версией, в которой использовался резистивный ЦАП, увеличена разрядность с 2-х до 8-и бит на цвет, и существенно улучшилось качество изображения.</p>
<p>Фото тестовой картинки:</p>
<p><a href="/images/2015/11/pic1.jpg"><img class="alignnone size-medium wp-image-2166" alt="pic" src="/assets/pic1-300x189.jpg" width="300" height="189" /></a></p>
<p>&nbsp;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Макет аналоговой части]]></title>
    <link href="http://arktur04.github.io/blog/2015/04/05/%25d0%25bc%25d0%25b0%25d0%25ba%25d0%25b5%25d1%2582-%25d0%25b0%25d0%25bd%25d0%25b0%25d0%25bb%25d0%25be%25d0%25b3%25d0%25be%25d0%25b2%25d0%25be%25d0%25b9-%25d1%2587%25d0%25b0%25d1%2581%25d1%2582%25d0%25b8/"/>
    <updated>2015-04-05T16:30:52+05:00</updated>
    <id>http://arktur04.github.io/blog/2015/04/05/%d0%bc%d0%b0%d0%ba%d0%b5%d1%82-%d0%b0%d0%bd%d0%b0%d0%bb%d0%be%d0%b3%d0%be%d0%b2%d0%be%d0%b9-%d1%87%d0%b0%d1%81%d1%82%d0%b8</id>
    <content type="html"><![CDATA[<p>Макет аналоговой части несложного прибора. Предназначен, в основном, для того, чтобы запустить устройство и отладить ПО, в дальнейшем он будет переделан на нормальной плате. Макетная плата была изготовлена давно, для другого проекта, и содержит, кроме макетного поля, различные узлы аналоговой схемотехники: двухполярный источник питания, источник опорного напряжения, инструментальный усилитель, АЦП, и т.п, но в данном случае эти узлы не используются и не смонтированы. Вентилятор предназначен для охлаждения платы, которая находится под этой платой и содержит цифровую часть, а также ЦАП и АЦП.</p>
<p>&nbsp;</p>
<p><a href="/images/2015/04/prototype.jpg"><img class="alignnone size-medium wp-image-2011" alt="prototype" src="/assets/prototype-300x198.jpg" width="300" height="198" /></a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Raspberry Pi и контроль температуры]]></title>
    <link href="http://arktur04.github.io/blog/2014/01/16/raspberry-pi-%25d0%25b8-%25d0%25ba%25d0%25be%25d0%25bd%25d1%2582%25d1%2580%25d0%25be%25d0%25bb%25d1%258c-%25d1%2582%25d0%25b5%25d0%25bc%25d0%25bf%25d0%25b5%25d1%2580%25d0%25b0%25d1%2582%25d1%2583%25d1%2580%25d1%258b/"/>
    <updated>2014-01-16T19:43:47+06:00</updated>
    <id>http://arktur04.github.io/blog/2014/01/16/raspberry-pi-%d0%b8-%d0%ba%d0%be%d0%bd%d1%82%d1%80%d0%be%d0%bb%d1%8c-%d1%82%d0%b5%d0%bc%d0%bf%d0%b5%d1%80%d0%b0%d1%82%d1%83%d1%80%d1%8b</id>
    <content type="html"><![CDATA[<p>Я уже <a href="http://32bit.me/?p=1768">писал</a> про самодельную "Time Capsule" на базе Raspberry Pi. Она работает хорошо, если не считать проблемы с перегревом. В корпусе устройства установлен вентилятор, но он издаёт при работе существенный шум.</p>
<p>Итак, я решил подключить к RPi термодатчик и сделать автоматическое управление вентилятором.</p>
<p><a href="/images/2014/01/temp1.png"><img class="alignnone size-medium wp-image-1790" title="temp1" src="/assets/temp1-300x225.png" alt="" width="300" height="225" /></a></p>
<p>Далее под катом.<br />
<!--more--><br />
Схемотехнически тут всё очень просто: термодатчик Analog Devices ADT7301 с интерфейсом SPI, вентилятор 40х40 мм, подключенный через транзисторный ключ к выходу PWM.</p>
<p><a href="/images/2014/01/2014-01-16-02.jpg"><img class="alignnone size-medium wp-image-1793" title="термодатчик" src="/assets/2014-01-16-02.jpg" alt="" width="300" height="198" /></a></p>
<p>Плата с термодатчиком.</p>
<p>Датчик приклеен к радиатору источника питания (самая горячая точка в устройстве).</p>
<p>Использование PWM позволяет включать вентилятор не на полные обороты, что делает его очень тихим. Управление вентилятором осуществляет скрипт на Python.</p>
<p>Перед тем, как запустить скрипт, нужно поставить библиотеки для доступа к SPI и PWM.</p>
<p><a href="https://github.com/doceme/py-spidev">py-spidev</a>: библиотека для SPI</p>
<p><a href="https://github.com/WiringPi">Wiring-Pi</a>: библиотека для доступа к GPIO и PWM.</p>
<p>Для получения доступа к SPI нужно отредактировать файл /etc/modprobe.d/raspi-blacklist.conf.</p>
<p>В нём находятся такие строки:</p>
<p>blacklist spi -bcm2708</p>
<p>blacklist i2c -bcm2708</p>
<p>Эти строки закрывают доступ к spi и i2c соответственно. Нужно закомментировать строку для spi:</p>
<p>#blacklist spi -bcm2708</p>
<p>и перезапускаем систему: sudo reboot.</p>
<p>Управление вентилятором ступенчатое: есть два порога включения вентилятора, на 50% и на 100%. Есть небольшая тонкость: если подать на выключенный вентилятор сигнал PWM c 50% -м заполнением, он просто не раскрутится: не хватит подаваемой мощности для пуска двигателя. Поэтому на двигатель подаётся сначала кратковременный импульс со 100% заполнением, которого хватает для пуска мотора.</p>
<p>В принципе, всё работает, однако хочется ещё и визуализировать данные температуры и оборотов вентилятора. Для этого были поставлены библиотеки <a href="http://www.numpy.org/">Numpy</a> и <a href="http://matplotlib.org/">Matplotlib</a>. Библиотека Matplotlib позволяет строить любые типы графиков, доступных в Matlab (то есть просто любые, в том числе 3D). Но тут же выяснилась и оборотная сторона: эти библиотеки очень тяжелые для RPi. Формирование картинки размером 800х600 с 2-d графиком занимает до 2-3 секунд (!), при частоте опроса датчика 1 раз в 5 с загрузка процессора составляет почти 100%, и достигает момента, когда RPi перестает откликаться на мышь и клавиатуру.</p>
<p>Пример получаемого графика температуры приведен в начале поста.</p>
<p>Исходный тескт скрипта приведен здесь:</p>
<pre lang="python">import spidev	#for spi
import wiringpi #for pwm
import time
from pylab import * #for chart
import matplotlib.pyplot as plt

tempTreshold1On = 50.0
tempTreshold1Off = 47.0
tempTreshold2On = 55.0
tempTreshold2Off = 52.0

speed0 = 0     # off
speed1 = 512   # 50% speed
speed2 = 1024  # 100% speed

#--------------------------------
#import 

# spi init
spi = spidev.SpiDev()
spi.open(0, 0)
# pwm init
wiringpi.wiringPiSetupGpio()
wiringpi.pinMode(18, 2)
wiringpi.pwmWrite(18, 1024)

n = 0 #current quantity of point in a chart
temp_points = [] #list of temperature points
speed_points = [] #list of fan speed points

speed = speed0
try:
	while True:
		# get 3 temperature values
		resp = spi.xfer2([0, 0])
		temp1 = resp[0] * 8 + resp[1]/32.0
		time.sleep(0.1)
		resp = spi.xfer2([0, 0])
		temp2 = resp[0] * 8 + resp[1]/32.0
		time.sleep(0.1)
		resp = spi.xfer2([0, 0])
		temp3 = resp[0] * 8 + resp[1]/32.0
		#----------------------
		#get the middle point of three values
		if ((temp1 &gt;= temp2) and (temp1 = temp3)):
			temp = temp1
		elif ((temp2 &gt;= temp1) and (temp2 = temp3)):
			temp = temp2
		else:
			temp = temp3
		#-------------------
		#find the current speed
		if temp &lt; tempTreshold1Off:
			speed = speed0
		if (temp &gt; tempTreshold1Off) and (temp &lt; tempTreshold1On):
			if speed == speed2:
				speed = speed1
		if (temp &gt; tempTreshold1On) and (temp &lt; tempTreshold2Off):
			if speed == speed0:
				wiringpi.pwmWrite(18, 1024) #turn on a motor at max speed
				time.sleep(0.5)
			speed = speed1
		if (temp &gt; tempTreshold2Off) and (temp &lt; tempTreshold2On):
			if speed == speed0:
				wiringpi.pwmWrite(18, 1024) #turn on a motor at max speed
				time.sleep(0.5)
				speed = speed1
		if temp &gt; tempTreshold2On:
			speed = speed2
		#-----------------------------
		# set the motor speed
		wiringpi.pwmWrite(18, speed)

		print temp1, temp2, temp3, "temp =", temp, speed
		# -----------------------------
		# draw a chart
		MAX_POINT = 12 # max quantity of point in the chart
		if n &lt; MAX_POINT:
			n = n + 1
		else:
			temp_points.pop(0) #remove the first point
			speed_points.pop(0) #remove the first point
		temp_points.append(temp)
		speed_points.append(speed * 100.0 / 1024.0) #fan speed in percents

		print temp_points

		fig, host = plt.subplots()

		par1 = host.twinx()
		t = arange((n - 1) * -5.0, 5.0, 5)

		print t

		p1, = host.plot(t, temp_points, "-b")
		p2, = par1.step(t, speed_points, "-r", where = "post")

		host.set_xlim(-60, 0)
		host.set_ylim(25, 75)
		par1.set_ylim(-10, 110)

		host.set_xlabel("Time, min")
		host.set_ylabel("Temperature, C")
		par1.set_ylabel("Speed, %")

		host.yaxis.label.set_color(p1.get_color())
		par1.yaxis.label.set_color(p2.get_color())

		host.grid()
		#host.text('temp = {}' .format(temp))
		savefig("temp.png")
		#show()

		time.sleep(5 * 60)  # period = 5 min
	#end while

except KeyboardInterrupt:
	spi.close()
#end try</pre>
<p>Скрипт нужно запускать командой sudo python spi.py</p>
<p>Некоторые пояснения к скрипту:<br />
Чтение термодатчика происходит 3 раза, после этого выбирается среднее значение (не среднее арифметическое, а значение, лежащее между двумя другими). Это позволяет отфильтровать случайные выбросы показаний датчика.</p>
<p>Порог выключения вентилятора ниже порога включения на 3 градуса, то есть функция включения вентилятора имеет некоторый гистерезис, это позволяет избежать частых включений и выключений двигателя (кстати, на графике вверху видно, что двигатель включается и выключается периодически, чтобы этого не происходило, нужно изменить пороговые значения).<br />
При включении двигателя на 50% мощности из выключенного состояния он кратковременно включается на полную мощность, причины поясняются выше.</p>
<p>В итоге я оставил в устройстве простой вариант скрипта, без визуализации. Можно попробовать другую библиотеку, полегче, но есть и другой способ. В настоящее время существуют облачные сервисы логгинга данных с датчиков, например, <a href="http://www.sensorcloud.com/">SensorCloud</a>. У сервиса есть документированное API, позволяющее отправлять данные по протоколу https. Если объем данных не превышает 3 млн. точек в месяц, сервисом можно пользоваться бесплатно.</p>
<p>Но это уже другая история.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Time Capsule своими руками]]></title>
    <link href="http://arktur04.github.io/blog/2013/09/14/time-capsule-%25d1%2581%25d0%25b2%25d0%25be%25d0%25b8%25d0%25bc%25d0%25b8-%25d1%2580%25d1%2583%25d0%25ba%25d0%25b0%25d0%25bc%25d0%25b8/"/>
    <updated>2013-09-14T13:35:45+06:00</updated>
    <id>http://arktur04.github.io/blog/2013/09/14/time-capsule-%d1%81%d0%b2%d0%be%d0%b8%d0%bc%d0%b8-%d1%80%d1%83%d0%ba%d0%b0%d0%bc%d0%b8</id>
    <content type="html"><![CDATA[<p>Для бэкапа содержимого жесткого диска в OS X, как известно, используется приложение Time Machine, очень удобное и качественное. Однако для его работы нужно устройство Time Capsule. В этом посте я хочу рассказать о том, как я сделал свою Time Capsule на основе Raspberry Pi.</p>
<p>Итак, нам понадобятся следующие компоненты:</p>
<p>1. Raspberry Pi и SD-карта для него;</p>
<p>2. HDD (я использовал HDD на 1 Tb, но можно взять жесткий диск и другого объёма);</p>
<p>3. переходник USB-SATA (от коробки для внешнего диска);</p>
<p>4. источник питания с напряжениями +5В и +12В, который может обеспечить силу тока по каналу +5В не менее 1,7А, по каналу 12В не менее 0,6А;</p>
<p>5. Wi-Fi адаптер для USB;</p>
<p>6. вентилятор (я использовал вентилятор 40 мм);</p>
<p>7. корпус;</p>
<p>Собираем всё вместе:</p>
<p><a href="/images/2013/09/2013-09-14-01.jpg"><img class="alignnone size-medium wp-image-1769" title="pic1" src="/assets/2013-09-14-01.jpg" alt="" width="300" height="225" /></a></p>
<p>(все картинки кликабельны)</p>
<p><!--more-->Перед установкой жесткого диска его необходимо отформатировать с файловой системой HFS+. Я воспользовался для этого утилитой MacDrive.</p>
<p>Итак, устанавливаем на SD-карту Linux Debian Wheezy и настраиваем всё согласно инструкции отсюда: <a href="http://www.raspberrypi.org/phpBB3/viewtopic.php?=63&amp;t=31511">http://www.raspberrypi.org/phpBB3/viewtopic.php?=63&amp;t=31511</a>.</p>
<p>Итак, всё готово, теперь Time Machine видит устройство и предлагает сделать резервную копию.</p>
<p><a href="/images/2013/09/pic2.jpg"><img class="alignnone size-medium wp-image-1770" title="pic2" src="/assets/pic2-300x186.jpg" alt="" width="300" height="186" /></a></p>
<p>Теперь остался последний штрих. Устройство потребляет (и, соответственно, рассеивает) довольно существенную мощность для такого маленького корпуса, поэтому нужно проверить температуру, до которой нагреваются наиболее горячие части устройства. Я проверял температуру радиатора блока питания (он нагревается сильнее всего, на втором месте винчестер).</p>
<p><a href="/images/2013/09/pic3.jpg"><img class="alignnone size-medium wp-image-1771" title="pic3" src="/assets/pic3-300x225.jpg" alt="" width="300" height="225" /></a></p>
<p>Максимальная температура, до которой нагревался радиатор при работе составила: с выключенным вентилятором &gt;60 °C, с включенным вентилятором ~40-42 °C. Проблема в том, что вентилятор издает довольно громкий звук. В принципе, 60 градусов можно считать приемлемой температурой, так что вентилятор можно отключить, но наиболее подходящим решением мне представляется следующее: подключить датчик температуры к RPi, подключить к нему же управление вентилятором (простой транзисторный ключ), и написать скрипт, который будет включать вентилятор по достижению порогового значения температуры (например, 50 °С), и выключать его при снижении температуры ниже другого порога (например, 45°С). Но это уже другая история.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Новый макет на макетной плате]]></title>
    <link href="http://arktur04.github.io/blog/2013/03/13/%25d0%25bd%25d0%25be%25d0%25b2%25d1%258b%25d0%25b9-%25d0%25bc%25d0%25b0%25d0%25ba%25d0%25b5%25d1%2582-%25d0%25bd%25d0%25b0-%25d0%25bc%25d0%25b0%25d0%25ba%25d0%25b5%25d1%2582%25d0%25bd%25d0%25be%25d0%25b9-%25d0%25bf%25d0%25bb%25d0%25b0%25d1%2582%25d0%25b5/"/>
    <updated>2013-03-13T19:47:32+06:00</updated>
    <id>http://arktur04.github.io/blog/2013/03/13/%d0%bd%d0%be%d0%b2%d1%8b%d0%b9-%d0%bc%d0%b0%d0%ba%d0%b5%d1%82-%d0%bd%d0%b0-%d0%bc%d0%b0%d0%ba%d0%b5%d1%82%d0%bd%d0%be%d0%b9-%d0%bf%d0%bb%d0%b0%d1%82%d0%b5</id>
    <content type="html"><![CDATA[<p>Макет нового устройства, собранный на специально разработанной для таких целей макетной плате. Плата содержит разведенные узлы АЦП, усилителей, источника опорного напряжения, источников тока и других аналоговых устройств, а также макетное поле и разъемы для подключения платы с микроконтроллером.</p>
<p><a href="/images/2013/03/board-3.jpg"><img class="alignnone size-medium wp-image-1702" title="board-3" src="/assets/board-3-300x218.jpg" alt="" width="300" height="218" /></a></p>
]]></content>
  </entry>
  
</feed>
