<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Scada | Записная книжка разработчика]]></title>
  <link href="http://arktur04.github.io/blog/categories/scada/atom.xml" rel="self"/>
  <link href="http://arktur04.github.io/"/>
  <updated>2016-03-23T21:05:14+05:00</updated>
  <id>http://arktur04.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Структура сети контроллеров]]></title>
    <link href="http://arktur04.github.io/blog/2010/11/18/%25d1%2581%25d1%2582%25d1%2580%25d1%2583%25d0%25ba%25d1%2582%25d1%2583%25d1%2580%25d0%25b0-%25d1%2581%25d0%25b5%25d1%2582%25d0%25b8-%25d0%25ba%25d0%25be%25d0%25bd%25d1%2582%25d1%2580%25d0%25be%25d0%25bb%25d0%25bb%25d0%25b5%25d1%2580%25d0%25be%25d0%25b2/"/>
    <updated>2010-11-18T21:22:52+05:00</updated>
    <id>http://arktur04.github.io/blog/2010/11/18/%d1%81%d1%82%d1%80%d1%83%d0%ba%d1%82%d1%83%d1%80%d0%b0-%d1%81%d0%b5%d1%82%d0%b8-%d0%ba%d0%be%d0%bd%d1%82%d1%80%d0%be%d0%bb%d0%bb%d0%b5%d1%80%d0%be%d0%b2</id>
    <content type="html"><![CDATA[<p><a href="/images/2010/11/controller_network.jpg"><img class="alignnone size-full wp-image-865" title="controller_network" src="/assets/controller_network.jpg" alt="" width="400" /></a></p>
<p>Пример структуры локальной сети, включающей в себя два контроллера i-8000, операторскую панель Weintek, и рабочее место оператора с SCADA-системой (там же запущен сервер SCADA-системы и ведётся архивирование трендов).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clear SCADA]]></title>
    <link href="http://arktur04.github.io/blog/2010/10/22/clear-scada/"/>
    <updated>2010-10-22T08:04:21+06:00</updated>
    <id>http://arktur04.github.io/blog/2010/10/22/clear-scada</id>
    <content type="html"><![CDATA[<p>Скриншоты из проекта двухлетней давности:</p>
<p><a href="/images/2010/10/fuel.jpg"><img class="alignnone size-medium wp-image-781" title="fuel" src="/assets/fuel-300x179.jpg" alt="" width="300" height="179" /></a></p>
<p>Проект был выполнен в SCADA-системе ClearSCADA и содержит более 100 экранных форм. Он служит для сбора данных и управления системой из двух контроллеров, объединённых локальной сетью (Ethernet). Также комплекс содержит операторскую панель.</p>
<p>Ещё скриншот под катом:</p>
<p><!--more--><a href="/images/2010/10/steam.jpg"><img class="alignnone size-medium wp-image-782" title="steam" src="/assets/steam-300x212.jpg" alt="" width="300" height="212" /></a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Протокол Modbus в устройствах на базе микроконтроллеров. Часть 1.4]]></title>
    <link href="http://arktur04.github.io/blog/2010/05/16/%25d0%25bf%25d1%2580%25d0%25be%25d1%2582%25d0%25be%25d0%25ba%25d0%25be%25d0%25bb-modbus-%25d0%25b2-%25d1%2583%25d1%2581%25d1%2582%25d1%2580%25d0%25be%25d0%25b9%25d1%2581%25d1%2582%25d0%25b2%25d0%25b0%25d1%2585-%25d0%25bd%25d0%25b0-%25d0%25b1%25d0%25b0%25d0%25b7%25d0%25b5-%25d0%25bc%25d0%25b8%25d0%25ba%25d1%2580%25d0%25be-6/"/>
    <updated>2010-05-16T19:11:37+06:00</updated>
    <id>http://arktur04.github.io/blog/2010/05/16/%d0%bf%d1%80%d0%be%d1%82%d0%be%d0%ba%d0%be%d0%bb-modbus-%d0%b2-%d1%83%d1%81%d1%82%d1%80%d0%be%d0%b9%d1%81%d1%82%d0%b2%d0%b0%d1%85-%d0%bd%d0%b0-%d0%b1%d0%b0%d0%b7%d0%b5-%d0%bc%d0%b8%d0%ba%d1%80%d0%be-6</id>
    <content type="html"><![CDATA[<p><em><a href="/images/2010/05/Рис-1.jpg"></a>Продолжение. </em><em>Начало здесь: </em><em> </em><a href="http://32bit.me/?p=355"><em>http://32bit.me/?p=355</em></a><em> - введение; </em><a href="http://32bit.me/?p=373"><em>http://32bit.me/?p=373</em></a><em> - часть 1.0; <a href="http://32bit.me/?p=377">http://32bit.me/?p=377</a> - часть 1.1; <a href="http://32bit.me/?p=395">http://32bit.me/?p=395</a> - часть 1.2; <a href="http://32bit.me/?p=406">http://32bit.me/?p=406</a> - часть 1.3.</em></p>
<p>Перед тем, как перейти к программной реализации поддержки протокола Modbus, необходимо прояснить ещё один вопрос.</p>
<p>Регистры протокола (3х и 4х) имеют разрядность 16 бит, а значения переменных, которые требуется передавать, часто имеют разрядность 32 бита. Каким образом 32-битные переменные передаются в 16-битных регистрах?</p>
<p><!--more-->Существует два способа решения этой проблемы. Первый из них заключается в замене значения переменной, передаваемой по Modbus, её 16-битным представлением путем линейной интерполяции.</p>
<p>При этом исходное значение называется "инженерным" (engineering, используется также термин engineering unit, или EU, для обозначения единиц исходного значения переменной), а передаваемые по сети данные называются "сырыми" (raw).</p>
<p>В SCADA - системе или в программе конфигурирования контроллера можно задать диапазон инженерных единиц, отображаемый на 16-ибитный диапазон (0-65535). При этом минимальное значение диапазона будет соответствовать 0, а максимальное - 65535.</p>
<p><a href="/images/2010/05/eng_units.jpg"><img class="alignnone size-full wp-image-420" title="eng_units" src="/assets/eng_units.jpg" alt="" width="509" height="365" /></a></p>
<p>Рис. 1. Настройка масштабирования в инженерные единицы в программе Easy Builder 8000 (конфигуратор панелей Weintek)</p>
<p>Второй способ заключается в передаче 32-битного значения в двух последовательно расположенных 16-битных регистрах. В современной практике чаще всего применяется именно этот способ.</p>
<p>Разместим в проекте панели переменную типа Float (т.е. вещественную 32-битную переменную) по адресу 1, а в конроллере - переменную вещественного типа с записанным в неё константным значением, например 123,456. Запрос выглядит так:</p>
<p>01 03 00 00 00 02 C4 0B</p>
<p>То есть ведущий запрашивает 2 регистра, начиная с регистра 0 (с адреса 1).</p>
<p>Ответ контроллера:</p>
<p>01 03 04 E9 79 42 F6 AF 50</p>
<p>Непосредственно блок данных выглядит так:  E9 79 42 F6. Что означают эти данные? Это и есть передаваемое вещественное число, при этом  в регистре с адресом 0 находятся младшие два байта, а в регистре с адресом 1 находятся старшие 2 байта, т.е. число в обычной форме записи выглядит как 42 F6 E9 79.</p>
<p>Обратимся к стандарту IEEE754. В двоичной форме число выглядит как 0100 0010 1111 0110 1110 1001 0111 1001.</p>
<p>Бит знака S = 0, экспонента E = 10000101, мантисса M = 11101101110100101111001.</p>
<p>F = (-1)<sup>S</sup>*2<sup>(E-127)</sup>(1 + M/2<sup>23</sup>) = 2<sup>6</sup>*(1 + 7793017/2<sup>23</sup>) = 64 * 1,929 = 123,456</p>
<p><em>Поскольку 32-битное число занимает 2 регистра Modbus, то переменные нужно размещать через один адрес, т.е., например, только по нечётным адресам.</em></p>
<p><em>Продолжение следует</em></p>
<p><strong>Владимир Татарчевский</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Протокол Modbus в устройствах на базе микроконтроллеров. Часть 1.3]]></title>
    <link href="http://arktur04.github.io/blog/2010/05/16/%25d0%25bf%25d1%2580%25d0%25be%25d1%2582%25d0%25be%25d0%25ba%25d0%25be%25d0%25bb-modbus-%25d0%25b2-%25d1%2583%25d1%2581%25d1%2582%25d1%2580%25d0%25be%25d0%25b9%25d1%2581%25d1%2582%25d0%25b2%25d0%25b0%25d1%2585-%25d0%25bd%25d0%25b0-%25d0%25b1%25d0%25b0%25d0%25b7%25d0%25b5-%25d0%25bc%25d0%25b8%25d0%25ba%25d1%2580%25d0%25be-5/"/>
    <updated>2010-05-16T01:54:45+06:00</updated>
    <id>http://arktur04.github.io/blog/2010/05/16/%d0%bf%d1%80%d0%be%d1%82%d0%be%d0%ba%d0%be%d0%bb-modbus-%d0%b2-%d1%83%d1%81%d1%82%d1%80%d0%be%d0%b9%d1%81%d1%82%d0%b2%d0%b0%d1%85-%d0%bd%d0%b0-%d0%b1%d0%b0%d0%b7%d0%b5-%d0%bc%d0%b8%d0%ba%d1%80%d0%be-5</id>
    <content type="html"><![CDATA[<p><em><a href="/images/2010/05/Рис-1.jpg"></a>Продолжение. </em><em>Начало здесь: </em><em> </em><a href="http://32bit.me/?p=355"><em>http://32bit.me/?p=355</em></a><em> - введение; </em><a href="http://32bit.me/?p=373"><em>http://32bit.me/?p=373</em></a><em> - часть 1.0; <a href="http://32bit.me/?p=377">http://32bit.me/?p=377</a> - часть 1.1; <a href="http://32bit.me/?p=395">http://32bit.me/?p=395</a> - часть 1.2.</em></p>
<p>Кратко рассмотрим обмен данными между ведущим и ведомым устройством для других типов регистров.</p>
<p><!--more--><strong>Регистры 0х, чтение</strong></p>
<p>Регистры 0х представляют собой 1-битные регистры с поддержкой как чтения, так и записи. Изначально они предусматривались для управления дискретными выходами (coil, обмотка реле), однако на практике могут использоваться как для входов, так и для выходов.</p>
<p>Разместим на панели, которой мы пользуемся для наших экспериментов, 8 дискретных индикаторов, присвоив им адреса с 1 до 8.</p>
<p>Запрос панели: 01 01 00 00 00 10 3D C6</p>
<p>В этом запросе:</p>
<p>01 - адрес устройства</p>
<p>01 - номер функции</p>
<p>00 00 - начальный адрес</p>
<p>00 10 - количество регистров, подлежащих чтению</p>
<p>3D C6 - контрольная сумма</p>
<p>Здесь видно, что панель опрашивает 10<sub>16</sub> = 16<sub>10</sub> входов, даже если реально ей нужно опросить только 8. Если входов, которые нужно опросить, больше 16, будут опрашиваться входы, в количестве, кратном 16. Такова особенность реализации данного ведущего устройства.</p>
<p>Ответ ведомого:</p>
<p>01 01 02 01 14 B8 63</p>
<p>01 - адрес устройства</p>
<p>01 - номер функции</p>
<p>02 - количество байт, которые будут переданы</p>
<p>01 14 - байты, соответствующие  состоянию дискретных регистров. 0-й бит первого байта соответствует начальному адресу. Таким образом, 01 14 соответствует следующему состоянию входов:</p>
<pre>----байт 01 ---  ---------байт 14 -----
0 1 2 3 4 5 6 7   8 9 10 11 12 13 14 15  N входа
1 0 0 0 0 0 0 0   0 0 1  0  1  0  0  0   состояние</pre>
<p><strong>Регистры 0х, запись</strong></p>
<p>Запрос панели:</p>
<p>01 05 00 1D  FF 00 1C 3C</p>
<p>01 - адрес устройства</p>
<p>05 - функция "Force Single Coil"</p>
<p>00 1D - адрес регистра</p>
<p>FF 00 - это значение используется, если нужно записать в регистр 1, в противном случае в этих байтах должно быть значение 00 00</p>
<p>1С 3С - контрольная сумма</p>
<p>Ответ ведомого совпадает с запросом:</p>
<p>01 05 00 1D  FF 00 1C 3C</p>
<p><strong>Регистры 1х, чтение</strong></p>
<p>Чтение из регистров 1х аналогично чтению из регистров 0х, меняется только номер функции с 01 на 02.</p>
<p>01 02 00 00 00 10 79 С6 - запрос ведущего</p>
<p>В этом запросе:</p>
<p>01 - адрес устройства</p>
<p>02 - номер функции</p>
<p>00 00 - начальный адрес</p>
<p>00 10 - количество регистров, подлежащих чтению</p>
<p>79 C6 - контрольная сумма</p>
<p>01 02 02 01 14 B8 27 - ответ ведомого</p>
<p>01 - адрес устройства</p>
<p>02 - номер функции</p>
<p>02 - количество байт, которые будут переданы</p>
<p>01 14 - байты, соответствующие  состоянию дискретных регистров. 0-й бит первого байта соответствует начальному адресу. Таким образом, 01 14 соответствует следующему состоянию входов:</p>
<pre>----байт 01 ---  ---------байт 14 -----
0 1 2 3 4 5 6 7   8 9 10 11 12 13 14 15  N входа
1 0 0 0 0 0 0 0   0 0 1  0  1  0  0  0   состояние</pre>
<p>Запись в регистры 1х не поддерживается.</p>
<p><strong>Регистры 3х чтение</strong></p>
<p>01 04 00 00 00 01 31 CA</p>
<p>Чтение из регистров 3х аналогично чтению из регистров 4х, номер функции меняется на 04.</p>
<p>Запрос ведущего:</p>
<p>01 - адрес ведомого</p>
<p>04 - номер функции</p>
<p>00 00 - начальный адрес</p>
<p>00 01 - количество регистров, подлежащих чтению</p>
<p>31 CA  - контрольная сумма</p>
<p>Ответ ведомого:</p>
<p>01 04 02 00 01 78 F0</p>
<p>01 - адрес ведомого</p>
<p>04 - номер функции</p>
<p>02 - количество байт, которые будут переданы</p>
<p>00 01 - состояние регистров, начиная с адреса, указанного в запросе</p>
<p>78 F0 - контрольная сумма</p>
<p>Запись в регистры 3х не поддерживается.</p>
<p>На этом рассмотрение команд протокола Modbus можно считаль законченным.</p>
<p>На примере обмена операторской панели с устройством при чтении регистров 0x мы видели, что панель запрашивает состояние 16 регистров даже если реально требуется прочитать меньшее их количество. Можно привести и другие аналогичные ситуации: так, например, OPC-сервер NAPOPC запрашивает регистры 4х порциями по 16 шт, даже когда нужно прочитать всего один. Вот его запрос (используется рассмотренная выше функция 03):<br />
01 03 00 00 00 10 44 06.<br />
А вот ответ ведомого:<br />
01 03 20 00 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0A 00 0B 00 0C 00 0D 00 0E 00 0F 00 00 EE 96.<br />
Конечно, такой подход крайне неэффективен с точки зрения производительности. Ненужные пересылки загружают сеть, увеличивая время реакции системы.</p>
<p><em>Продолжение следует</em></p>
<p><strong>Владимир Татарчевский</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Протокол Modbus в устройствах на базе микроконтроллеров. Часть 1.2]]></title>
    <link href="http://arktur04.github.io/blog/2010/05/13/%25d0%25bf%25d1%2580%25d0%25be%25d1%2582%25d0%25be%25d0%25ba%25d0%25be%25d0%25bb-modbus-%25d0%25b2-%25d1%2583%25d1%2581%25d1%2582%25d1%2580%25d0%25be%25d0%25b9%25d1%2581%25d1%2582%25d0%25b2%25d0%25b0%25d1%2585-%25d0%25bd%25d0%25b0-%25d0%25b1%25d0%25b0%25d0%25b7%25d0%25b5-%25d0%25bc%25d0%25b8%25d0%25ba%25d1%2580%25d0%25be-4/"/>
    <updated>2010-05-13T17:51:44+06:00</updated>
    <id>http://arktur04.github.io/blog/2010/05/13/%d0%bf%d1%80%d0%be%d1%82%d0%be%d0%ba%d0%be%d0%bb-modbus-%d0%b2-%d1%83%d1%81%d1%82%d1%80%d0%be%d0%b9%d1%81%d1%82%d0%b2%d0%b0%d1%85-%d0%bd%d0%b0-%d0%b1%d0%b0%d0%b7%d0%b5-%d0%bc%d0%b8%d0%ba%d1%80%d0%be-4</id>
    <content type="html"><![CDATA[<p><em><a href="/images/2010/05/Рис-1.jpg"></a>Продолжение. </em><em>Начало здесь: </em><em> </em><a href="http://32bit.me/?p=355"><em>http://32bit.me/?p=355</em></a><em> - введение; </em><a href="http://32bit.me/?p=373"><em>http://32bit.me/?p=373</em></a><em> - часть 1.0; <a href="http://32bit.me/?p=377">http://32bit.me/?p=377</a> - часть 1.1.</em></p>
<p>Перед тем, как приступить к дальнейшим экспериментам с протоколом Modbus, разберёмся с ещё одной темой, относящейся к этому протоколу: с регистрами Modbus.</p>
<p><!--more-->Каждая переменная, которую ведущее устройство считывает/записывает из ведомого устройства, имеет 16-битный адрес. Но помимо адреса, есть ещё тип регистра, обозначаеый обычно цифрой от 0 до 6 и буквой x, например 4х. Часто адрес переменной записывается, например, так: 400001. Это означает, что адрес переменной равен 1, и она относится к типу 4. Максимальное значение адреса равно 65535, поэтому для переменных типа 4 полные адреса будут находиться в диапазоне от 400001 до 465535 (от 40001<sub>16</sub> до 4FFFF<sub>16</sub>).</p>
<p>Что означает тип переменной? Итак:</p>
<p>0  - Output coil (дискретные выходы)</p>
<p>1 - Discrete Inputs (дискретные входы)</p>
<p>3 - Input Registers (входные регистры)</p>
<p>4 - Holding Registers (регистры хранения)</p>
<p>5 - фактически используются регистры типа 4, но производится перестановка байт, она будет рассмотрена ниже.</p>
<p>6 - Extended Memory File. Используется крайне редко, и здесь рассматриваться не будет.</p>
<p>Как мы видим, типа 2 не существует. Также, мы уже упоминали о том, что адрес, передающийся в посылке протокола, на 1 меньше, чем адрес регистра. Поэтому адреса Modbus нумеруются, начиная с 1, а не с 0. Максимальное же значенме адреса регистра равно 65535, а не 65536, как можно было бы подумать. Однако такое ограничение не очень существенно, так как реальные устройства редко имеют 65536 переменных, передаваемых по Modbus.</p>
<p>На практике обычно используются регистры тиов 0х и 1х для дискретных входов-выходов (1-битных), 3х и 4х для 16-битных переменных. Тип 5х фактически заменяется на тип 4х.</p>
<p>Формально, переменные с адресами 100001 и 400001 - разные переменные, так как, хотя они имеют одинаковый адрес регистра (1), они относятся к разным типам, к разным адресным пространствам. На практике же это не так. Сделать в одном устройстве переменные разных типов с одинаковыми адресами - грубая ошибка. Почему это так?</p>
<p>Откроем среду разработки ISaGRAF, зайдём в Словарь переменных, и попробуем добавить 2 переменные с одним и тем же адресом, скажем, 10, но одну в раздел "Целые/Действительные", а другую в раздел "Булевские". Теперь откроем карту адресов Modbus. Что мы видим? Там отображается только одна из введённых нами переменных, другим адрес просто не назначен. Более того, ISaGRAF просто отображает адресные пространства всех типов в на одну, общую карту адресов. Вы можете записать переменную типа 0х по адресу 10, а потом считать её значение по адресу 400010.</p>
<p>И если в вашем устройстве будут 2 переменные с адресами 10 и 400010, то контроллер под управлением ISaGRAF не сможет с ним работать.</p>
<p>И, хотя многие другие контроллеры разделяют переменные в различных типах регистров, лучше всего будет, если вы не будете рисковать, создавая переменные с одним адресом, но в разных типах регистров.</p>
<p>Из вышесказанного можно сделать важный вывод: мы можем сильно упростить задачу реализации ведомого устройства Modbus (т.е. Modbus slave), если ограничимся поддержкой только регистров типа 4х, самых универсальных, допускающих как чтение, так и запись. В описанных выше экспериментах с контроллером и панелью использовались именно регистры типа 4х.</p>
<p>Приведём список функций протокола Modbus</p>
<p>1 - Read coil (Чтение состояния выходов, регистры 0х)</p>
<p>2 - Read Discrete input (Чтение состояния входов, регистры 1х)</p>
<p>3 - Read holding register (Чтение регистров 4х)</p>
<p>4 - Read input register (Чтение регистров 3х)</p>
<p>5 - Write single coil (Запись состояния выходов, регистры 0х)</p>
<p>6 - Write single register (Запись одного регистра 4х)</p>
<p>10<sub>16</sub> (16) - Write multiple register (Запись множества регистров 4х)</p>
<p>Остальные функции протокола используются крайне редко и здесь рассматриваться не будут.</p>
<p>Регистры типа 1х и 3х не поддерживают операции записи. Изначально они задумывались как регистры для входных переменных, однако никто не мешает использовать в качестве входных переменных регистры 0x и 4x. Именно поэтому чаще всего используются именно  0x и 4x, причём наиболее универсальными регистрами являются регистры 4x.</p>
<p>В описанных выше экспериментах мы наблюдали, что при обмене данными между панелью и контроллером использовались функции 3 и 10<sub>16</sub> .  Протоколом также предусмотрена функция 6 - запись одиночного регистра 4х, она используется редко, но некоторые ведущие устройства и OPC-сервера всё-таки могут её использовать.</p>
<p><em>OPC-сервер - это промежуточное звено, своего рода посредник между системой сбора данных (SCADA-системой) и сетью промышленных контроллеров.  ОРС-сервер представляет собой программу, поддерживающую тот или ной протокол (например, Modbus), с одной стороны, и предоставляющую унифицированный прогаммный интерфейс доступа к данным с другой стороны. OPC-сервера - тема отдельной статьи, здесь они подробно рассматриваться не будут.</em></p>
<p>Самый важный вывод, который можно сделать из перечисленного, состоит в том, что для реализации протокола Modbus в slave-устройстве достаточно поддерживать всего три функции: 3, 6 и 10<sub>16</sub>. Это позволит записывать и считывать как целочисленные 16-битные, так и однобитные переменные, представляя последние как нулевое либо ненулевое значение регистра.</p>
<p>Многие ведущие (masters) также предоставляют возможность работы с регистрами 3x и 4x как с набором из 16-и дискретных переменных, в этом случае для каждой переменной указывается адрес регистра и номер бита от 0 до 15.</p>
<p><em>Продолжение следует.</em></p>
<p><strong>Владимир Татарчевский</strong></p>
]]></content>
  </entry>
  
</feed>
