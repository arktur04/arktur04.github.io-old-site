<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Fpga | My Octopress Blog]]></title>
  <link href="http://arktur04.github.io/blog/categories/fpga/atom.xml" rel="self"/>
  <link href="http://arktur04.github.io/"/>
  <updated>2015-12-10T04:05:20+05:00</updated>
  <id>http://arktur04.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Проект видеоадаптера. Часть 3]]></title>
    <link href="http://arktur04.github.io/blog/2015/11/23/%25d0%25bf%25d1%2580%25d0%25be%25d0%25b5%25d0%25ba%25d1%2582-%25d0%25b2%25d0%25b8%25d0%25b4%25d0%25b5%25d0%25be%25d0%25b0%25d0%25b4%25d0%25b0%25d0%25bf%25d1%2582%25d0%25b5%25d1%2580%25d0%25b0-%25d1%2587%25d0%25b0%25d1%2581%25d1%2582%25d1%258c-3/"/>
    <updated>2015-11-23T21:00:45+05:00</updated>
    <id>http://arktur04.github.io/blog/2015/11/23/%d0%bf%d1%80%d0%be%d0%b5%d0%ba%d1%82-%d0%b2%d0%b8%d0%b4%d0%b5%d0%be%d0%b0%d0%b4%d0%b0%d0%bf%d1%82%d0%b5%d1%80%d0%b0-%d1%87%d0%b0%d1%81%d1%82%d1%8c-3</id>
    <content type="html"><![CDATA[<p>Продолжение. <a href="http://32bit.me/?p=2156">Часть 2.</a></p>


<p>Структурная схема видеоадаптера приведена на рис. 1 (кликабельно)</p>


<p><a href="http://32bit.me/wordpress/wp-content/uploads/2015/11/vga-card-big.jpg"><img class="alignnone size-medium wp-image-2175" alt="vga-card-big" src="/assets/vga-card-big-300x214.jpg" width="300" height="214" /></a></p>


<p>&nbsp;</p>


<p>Рис. 1. Структурная схема видеоадаптера.</p>


<p>&nbsp;</p>


<p>Пояснения к схеме:</p>


<p>В первой версии видеоадаптер будет иметь только текстовый режим EGA, 80 * 25 символов 8 * 14 пикселов каждый символ. Таким образом, экранное разрешение составит 8 * 80 = 640 пикселов по горизонтали и 14 * 25 = 350 пикселов по вертикали. Частота пикселов в этом режиме составляет, по стандарту 25,175 МГц, фактическая частота будет 25 МГц, в связи с тем, что частота тактирования ПЛИС составляет 50 МГц. При этом на любом мониторе происходит нормальная синхронизация.</p>


<p><!--more--></p>


<p>Для аналогичного тектового видеорежима VGA разрешение составляет 720 * 400 пикселей, т.к. символы имеют размер 9*16 пикселей. Частота пикселов при этом должна быть 28,322 МГц, и нормальная синхронизация с частотой 25 МГц невозможна. Можно получить близкую частоту с помощью PLL, но тогда потребуются блоки для асинхронного сопряжения видеоадаптера с микропроцессорной частью проекта, т.к. микропроцессорная часть будет тактироваться частотой 50 МГц. Это будет следующим этапом проекта, пока вся схема будет тактироваться от 50 МГц.</p>


<p>Графические режимы тоже будут позже, пока будет реализован максимально простой вариант.</p>


<p>Некоторые пояснения по схеме:</p>


<p><strong>sync_gen</strong> - генератор синхроимпульсов. Имеет выходы <em>h_coord_reg</em> и <em>v_coord_reg</em>, соответственно, текущие координаты пиксела по горизонтали и вертикали. <em>data_en</em> - сигнал разрешения данных. Этот же сигнал используется для "гашения" выходов ЦАП. <em>hsync_reg</em> и<em> vsync_reg</em> - сигналы горизонтальной и вертикальной синхронизации.</p>


<p>Так как вся схема состоит из нескольких модулей, включенных последовательно, прохождение сигнала по ним занимает несколько тактов. В связи с этим сигналы <em>data_en, <em>hsync_reg</em> </em>и <em><em>vsync_reg</em></em> также должны быть задержаны, чтобы приходить на выход синхронно с сигналами соответствующего пиксела.</p>


<p><strong>addr_decoder</strong> - так как видеоадаптер будет использовать в качестве видеопамяти внешнюю sdram, которая будет использоваться совместно с основным микропроцессором, <strong> </strong>необходимо иметь небольшую буферную память, чтобы избежать проблем, связанных с временем доступа к внешней памяти. Этот буфер будет двойным, пока идёт выборка из одного блока памяти, в другой загружаются данные из внешней памяти, затем они меняются местами. каждый блок памяти будет иметь размер 256*16 бит. 16-и битный выход позволит получит сразу и ком символа, и информацию об его цвете. Модуль <strong>addr_decoder</strong> вырабатывает текущий адрес в буфере <em>buffer_addr_reg</em>, исходя из текущей координаты пиксела и смещения буфера (т.е. адреса, который отображается на начало буфера). Также этот модуль вырабатывает сигналы <em>hmod_reg</em> и <em>vmod_reg</em>, которые являются координатой пиксела в текущем знакоместе (т.е. абсолютной координатой по модулю 8 и 14 соответственно).</p>


<p><strong>buf_mem </strong> - буфер памяти, см. предыдущий абзац.</p>


<p><strong>mem_controlle</strong>r - контроллер памяти. Должен обеспечивать подкачку содержимого буфера из внешней SDRAM. Также, в будущем, будет обеспечивать асинхронные взаимодействия видеоадаптера и основной части, при их работе на разной тактовой частоте.</p>


<p><strong>mode_controller</strong> - контроллер видеорежима. Пока видеоадаптер будет иметь только один текстовый режим, но в будущем контроллер должен будет обесипечивать установку всех остальных модулей в состояние, соответствующее текущему видеорежиму. Также модуль выделяет код символа (<em>char_code_reg</em>), цвет символа (<em>char_color_reg</em>), цвет фона (<em>back_color_reg</em>) и признак мигания <em>blink</em>.</p>


<p><strong>char_gen</strong> - знакогенератор. В данной версии представляет собой ПЗУ с таблицей символов EGA (8*14), но впоследствии будет содержать символы VGA (9*16) и символы 8*8, а также программируемые пользователем символы. На его вход поступает код символа (<em>char_code</em>) и номер строки символа (<em>vmod</em>), на выходе появляется строка текущего знакоместа (<em>char_data_reg</em>).</p>


<p><strong>pixel_data_decode</strong>r - на основании сигналов <em>char_data, hmod, char_color, back_color, blink</em> определяет цвет текущего пиксела в палитре.</p>


<p><strong>palette</strong> - регистры палитры. В данной версии представляет собой ПЗУ, в дальнейшем будет возможность его изменения пользовательской программой.</p>


<p>Пока это черновик схемы, она будет дорабатываться и изменяться по мере продвижения проекта.</p>


<p>&nbsp;</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Проект видеоадаптера. Часть 2]]></title>
    <link href="http://arktur04.github.io/blog/2015/11/05/vga-%25d0%25b0%25d0%25b4%25d0%25b0%25d0%25bf%25d1%2582%25d0%25b5%25d1%2580-%25d0%25bd%25d0%25b0-fpga/"/>
    <updated>2015-11-05T21:38:06+05:00</updated>
    <id>http://arktur04.github.io/blog/2015/11/05/vga-%d0%b0%d0%b4%d0%b0%d0%bf%d1%82%d0%b5%d1%80-%d0%bd%d0%b0-fpga</id>
    <content type="html"><![CDATA[<p>Продолжение. <a title="Начало" href="http://32bit.me/?p=2037">Начало</a>.</p>


<p>Проект видеоадаптера переделан под использование видео ЦАП ADV7123. Схема подключения приведена на рисунке:</p>


<p><a href="http://32bit.me/wordpress/wp-content/uploads/2015/11/VGA_DAC.jpg"><img class="alignnone size-medium wp-image-2168" alt="VGA_DAC" src="/assets/VGA_DAC-300x190.jpg" width="300" height="190" /></a></p>


<p>(по клику откроется полный размер).</p>


<p>Код проекта приведён на гитхабе (<a href="https://github.com/arktur04/VideoCard">ссылка</a>). Это тестовый код, который выводит на монитор поле разноцветных квадратов.</p>


<p>По сравнению с предыдущей версией, в которой использовался резистивный ЦАП, увеличена разрядность с 2-х до 8-и бит на цвет, и существенно улучшилось качество изображения.</p>


<p>Фото тестовой картинки:</p>


<p><a href="http://32bit.me/wordpress/wp-content/uploads/2015/11/pic1.jpg"><img class="alignnone size-medium wp-image-2166" alt="pic" src="/assets/pic1-300x189.jpg" width="300" height="189" /></a></p>


<p>&nbsp;</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Драйвер для Linux: первый шаг]]></title>
    <link href="http://arktur04.github.io/blog/2015/10/02/%25d0%25b4%25d1%2580%25d0%25b0%25d0%25b9%25d0%25b2%25d0%25b5%25d1%2580-%25d0%25b4%25d0%25bb%25d1%258f-linux-%25d0%25bf%25d0%25b5%25d1%2580%25d0%25b2%25d1%258b%25d0%25b9-%25d1%2588%25d0%25b0%25d0%25b3/"/>
    <updated>2015-10-02T22:11:34+05:00</updated>
    <id>http://arktur04.github.io/blog/2015/10/02/%d0%b4%d1%80%d0%b0%d0%b9%d0%b2%d0%b5%d1%80-%d0%b4%d0%bb%d1%8f-linux-%d0%bf%d0%b5%d1%80%d0%b2%d1%8b%d0%b9-%d1%88%d0%b0%d0%b3</id>
    <content type="html"><![CDATA[<p>Продолжаю эксперименты с Altera Cyclone V. На этот раз объектом эксперимента стал драйвер для той прошивки FPGA, про которую я писал ранее. Сама прошивка простейшая: она просто мигает светодиодами с частотой, которую можно задавать программно. В прошлом посте на эту тему я сделал управление частотой мигания из обычной (user-space) программы, которая получает доступ к физической памяти через функции open("/dev/mem") и mmap().<br />
Однако такой путь считается "hacky and unsafe". Поэтому следующим логичным шагом должно стать написание драйвера.</p>


<p><a href="http://32bit.me/wordpress/wp-content/uploads/2015/10/Tux-linux-and-ARM-multiplatform-support.jpg"><img class="alignnone size-full wp-image-2147" alt="Tux-linux-and-ARM-multiplatform-support" src="/assets/Tux-linux-and-ARM-multiplatform-support.jpg" width="672" height="370" /></a></p>


<p>Я воспользовался готовым исходником драйвера (<a href="https://github.com/zhemao/sockit_test/tree/master/software/blinker">ссылка</a>) за авторством Howard Mao (он на самом деле не Howard, а Zhe Hao Mao). Конечно, для того, чтобы разобраться в работе кода, почитал отдельные главы книги Linux Device Drivers (есть русский перевод).</p>


<p>Для компиляции пришлось вытаскивать архив Arrow SocKit 13.1 GSRD Linux отсюда: <a href="http://releases.rocketboards.org/release/2013.11/gsrd/src">http://releases.rocketboards.org/release/2013.11/gsrd/src</a>, файл linux-socfpga-gsrd-13.1-src.bsx. Объем архива около 1.1 Гб, но сервер очень медленный, качается несколько часов. Честно говоря, я впервые увидел файл с расширением bsx, оказалось, что это самораспаковывающийся архив. Просто запускаем его и он разворачивается в указанную папку. В ней в папке sources находится файл linux-socfpga.tgz. Его тоже нужно распаковать, естественно. Это и есть как таковое ядро системы, которое нужно указывать при компиляции драйвера.</p>


<p>Однако всё не так просто. После компиляции записываем скомпилированный драйвер blinker.ko на SD-карту, после загрузки Linux пишем<strong> insmod blinker.ko</strong> и получаем следующее: "<em>blinker: version magic '3.9.0-00161-ged01b8c SMP mod_unload ARMv7 p2v8 ' should be '3.9.0 SMP mod_unload ARMv7 p2v8'</em>". Не совпали волшебные номерки. Причем версия одна и та же, просто зачем-то к ней приделан какой-то добавочный номер.</p>


<p>Решений может быть три: 1. Скомпилировать Linux именно из этого скачанного исходника (очень неохота) или 2. Подправить номер в исходниках ядра Linux. 3. Использовать команду modprobe с ключом -f, который заставляет систему игнорировать "волшебные цифры".  Однако этот способ почему-то не заработал.<br />
Итак, способ номер 2, подправить номер в исходнике ядра. Данный номер записан в файле /include/generated/utsrelease.h. Исправляем то, что там было, на "3.9.0", и перекомпилируем драйвер. На всякий случай смотрим hex-редактором файл blinker.ko, чтобы убедиться, что волшебные циферки такие, как нужно. Снова записываем драйвер на SD-карту, запускаем insmod, всё прошло гладко. Теперь можно проверить работу драйвера, посылая ему числа от 1 до 15 для управления частотой миганий: echo 1 &gt; blinker - мигает быстро, echo 15 &gt; blinker - мигает медленно. Пока всё. Немного, но путь в тысячу ли начинается с одного шага.</p>


<p>Эксперименты продолжаются.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Управление FPGA из программы]]></title>
    <link href="http://arktur04.github.io/blog/2015/09/23/%25d1%2583%25d0%25bf%25d1%2580%25d0%25b0%25d0%25b2%25d0%25bb%25d0%25b5%25d0%25bd%25d0%25b8%25d0%25b5-fpga-%25d0%25b8%25d0%25b7-%25d0%25bf%25d1%2580%25d0%25be%25d0%25b3%25d1%2580%25d0%25b0%25d0%25bc%25d0%25bc%25d1%258b/"/>
    <updated>2015-09-23T20:51:35+05:00</updated>
    <id>http://arktur04.github.io/blog/2015/09/23/%d1%83%d0%bf%d1%80%d0%b0%d0%b2%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5-fpga-%d0%b8%d0%b7-%d0%bf%d1%80%d0%be%d0%b3%d1%80%d0%b0%d0%bc%d0%bc%d1%8b</id>
    <content type="html"><![CDATA[<p>Приведённый ниже код писал не я, он взят отсюда:<a href="https://zhehaomao.com/blog/fpga/2013/12/27/sockit-3.html"> https://zhehaomao.com/blog/fpga/2013/12/27/sockit-3.html</a>, но я решил оставить его здесь, т.к. он пригодится для дальнейших экспериментов.</p>


<p>Напоминаю, что данная программа работает в ОС Linux GSRD на SoC Altera Cyclone V (ядро ARM Cortex A9). Компилятор Linaro GCC, берём здесь: <a href="http://releases.linaro.org/latest/components/toolchain/binaries/4.8/arm-linux-gnueabihf/">http://releases.linaro.org/latest/components/toolchain/binaries/4.8/arm-linux-gnueabihf/</a></p>


<pre lang="c" line="1">#include <sys/mman.h>;
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdint.h>

#define PAGE_SIZE 4096
#define LWHPS2FPGA_BRIDGE_BASE 0xff200000
#define BLINK_OFFSET 0x0

volatile unsigned char *blink_mem;
void *bridge_map;

int main(int argc, char *argv[])
{
    int fd, ret = EXIT_FAILURE;
    unsigned char value;
    off_t blink_base = LWHPS2FPGA_BRIDGE_BASE;

    if (argc < 2) {
        fprintf(stderr, "Usage: %s number\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    /* check the bounds of the value being set */
    value = atoi(argv[1]);
    if (value < 1 || value > 15) {
        fprintf(stderr, "Invalid delay setting."
                "Delay must be between 1 and 15, inclusive.\n");
        exit(EXIT_FAILURE);
    }

    /* open the memory device file */
    fd = open("/dev/mem", O_RDWR|O_SYNC);
    if (fd < 0) {
        perror("open");
        exit(EXIT_FAILURE);
    }

    /* map the LWHPS2FPGA bridge into process memory */
    bridge_map = mmap(NULL, PAGE_SIZE, PROT_WRITE, MAP_SHARED,
                fd, blink_base);
    if (bridge_map == MAP_FAILED) {
        perror("mmap");
        goto cleanup;
    }

    /* get the delay_ctrl peripheral's base address */
    blink_mem = (unsigned char *) (bridge_map + BLINK_OFFSET);

    /* write the value */
    *blink_mem = value;

    if (munmap(bridge_map, PAGE_SIZE) < 0) {
        perror("munmap");
        goto cleanup;
    }

    ret = 0;

cleanup:
    close(fd);
    return ret;
}</stdint.h></unistd.h></stdlib.h></stdio.h></fcntl.h></pre>


<p>Программа управляет частотой мигания светодиода, сам делитель частоты расположен в FPGA, частота задаётся регистром.</p>


<p><!--more--></p>


<p>Если убрать все строки, отвечающие за обработку ошибок, то остаётся это:</p>


<pre lang="c" line="1">bridge_map = mmap(NULL, PAGE_SIZE, PROT_WRITE, MAP_SHARED,
            fd, blink_base);
blink_mem = (unsigned char *) (bridge_map + BLINK_OFFSET);
*blink_mem = value;</pre>


<p>Здесь мы отображаем функцией mmap страницу памяти моста lwhps2fpga в пространство памяти процесса.</p>


<pre lang="bash" line="1"># enable the lwhps2fpga bridge
echo 1 > /sys/class/fpga-bridge/lwhps2fpga/enable
# make it blink fast
./blinker 1
# make it blink slow
./blinker 15</pre>


<p>Продолжение следует.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Прошиваем FPGA в Run-time]]></title>
    <link href="http://arktur04.github.io/blog/2015/08/21/%25d0%25bf%25d1%2580%25d0%25be%25d1%2588%25d0%25b8%25d0%25b2%25d0%25b0%25d0%25b5%25d0%25bc-fpga-%25d0%25b2-run-time/"/>
    <updated>2015-08-21T22:22:04+05:00</updated>
    <id>http://arktur04.github.io/blog/2015/08/21/%d0%bf%d1%80%d0%be%d1%88%d0%b8%d0%b2%d0%b0%d0%b5%d0%bc-fpga-%d0%b2-run-time</id>
    <content type="html"><![CDATA[<p>В общем, ничего сложного.<br />
Для того, чтобы заливать прошивку в FPGA из процессорного ядра, нужно сделать следующее:<br />
1. Подготовить файл rbf, это и есть файл прошивки. Он делается из файла sof с помощью утилиты Quartus:</p>


<p>quartus_cpf -c output_files/sockit_test.sof output_files/sockit_test.rbf</p>


<p>Положить этот файл в основной раздел SD-карты, например, в корень.</p>


<p>2. После загрузки linux, отключить мосты между FPGA и HPS (HPS - это процессорное ядро):</p>


<p>echo 0 &gt; /sys/class/fpga-bridge/fpga2hps/enable<br />
echo 0 &gt; /sys/class/fpga-bridge/hps2fpga/enable<br />
echo 0 &gt; /sys/class/fpga-bridge/lwhps2fpga/enable</p>


<p>И заливаем файл в FPGA:</p>


<p>dd if=/sockit_test.rbf of=/dev/fpga0 bs=1M</p>


<p>Собственно, всё. Мосты можно включить обратно, если нужно:</p>


<p>echo 1 &gt; /sys/class/fpga-bridge/fpga2hps/enable<br />
echo 1 &gt; /sys/class/fpga-bridge/hps2fpga/enable<br />
echo 1 &gt; /sys/class/fpga-bridge/lwhps2fpga/enable</p>


<p>Разумеется, всё это можно делать скриптом.<br />
Пишем файл gsrd_init.sh:</p>


<pre lang="bash" line="1">#!/bin/sh

echo 0 > /sys/class/fpga-bridge/fpga2hps/enable
echo 0 > /sys/class/fpga-bridge/hps2fpga/enable
echo 0 > /sys/class/fpga-bridge/lwhps2fpga/enable
dd if=/sockit_test.rbf of=/dev/fpga0 bs=1M
echo 1 > /sys/class/fpga-bridge/fpga2hps/enable
echo 1 > /sys/class/fpga-bridge/hps2fpga/enable
echo 1 > /sys/class/fpga-bridge/lwhps2fpga/enable
</pre>


<p>Кладём его в /etc/init.d. Теперь после загрузки Linux прошивка FPGA будет загружаться автоматически.</p>

]]></content>
  </entry>
  
</feed>
