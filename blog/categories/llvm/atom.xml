<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Llvm | Записная книжка разработчика]]></title>
  <link href="http://arktur04.github.io/blog/categories/llvm/atom.xml" rel="self"/>
  <link href="http://arktur04.github.io/"/>
  <updated>2016-01-04T20:27:53+05:00</updated>
  <id>http://arktur04.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Книга Chen Chung-Shu "Creating an LLVM Backend for the Cpu0 Architecture"]]></title>
    <link href="http://arktur04.github.io/blog/2016/01/04/knigha-chen-chung-shu-creating-an-llvm-backend-for-the-cpu0-architecture/"/>
    <updated>2016-01-04T20:17:43+05:00</updated>
    <id>http://arktur04.github.io/blog/2016/01/04/knigha-chen-chung-shu-creating-an-llvm-backend-for-the-cpu0-architecture</id>
    <content type="html"><![CDATA[<p>Прочитал книгу Chen Chung-Shu "Creating an LLVM Backend for the Cpu0 Architecture", 575 стр., англ. язык.
Книга по LLVM, единственная в своём роде книга, детально описывающая процесс разработки бэкенда.</p>

<p><a href="/images/2016/01/line-tile.png"><img title="Creating an LLVM Backend for the Cpu0 Architecture" src="/2016/01/line-tile.png" alt="" height="300" /></a></p>

<p>Я читал эту книгу ранее, но автор непрерывно вносит исправления и дополнения в текст (эта книга существует только в онлайновом виде), поэтому я решил перечитать всё полностью, с начала до конца, самый свежий вариант. Сейчас я могу сказать, что читал по LLVM всё, что опубликовано, и что имеет хотя бы немного существенное значение (можно также найти огромное количество статей в духе “мы разработали компилятор для нашего процессора, это круто”. Их я обычно не читаю). Источников по LLVM очень мало, печатных книг всего две, например.</p>

<p>Проблема ещё и в том, что все процессоры разные, и нельзя просто скопировать исходник одного бэкенда, подправить там пару строк и получить другой. Они настолько различны, что вряд ли вы вообще найдёте в двух разных бэкендах похожие куски кода. Поэтому чтение этой книги не заменит вам собственного опыта.
Желающим разработать свой компилятор, я могу посоветовать следующее:
не бояться разбираться в существующем коде, как бэкендов, так и Core Library.
не бояться экспериментировать и писать с нуля собственные алгоритмы оптимизаций.
не пытаться изобрести велосипед. Если нужные функции есть в Core Library, их необходимо изучить и использовать. Если, напротив, каких-то функций нет ни в Core Library, ни в других бэкендах, значит, скорее всего, вы хотите странного, и, скорее всего, на самом деле это вам не нужно. Хотя могут быть исключения из этого правила.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Про LLVM]]></title>
    <link href="http://arktur04.github.io/blog/2015/10/25/%25d0%25bf%25d1%2580%25d0%25be-llvm/"/>
    <updated>2015-10-25T09:03:32+05:00</updated>
    <id>http://arktur04.github.io/blog/2015/10/25/%d0%bf%d1%80%d0%be-llvm</id>
    <content type="html"><![CDATA[<p>LLVM (начало статьи)</p>
<p>На сегодняшний день существует только два реалистичных пути разработки компилятора для собственной архитектуры: использование GCC либо использование LLVM. Другие проекты компиляторов с открытым исходным кодом либо не достигли той степени развития, как GCC и LLVM, либо устарели и перестали развиваться, они не обладают развитыми алгоритмами оптимизации, и могут не обеспечивать полной совместимости даже со стандартом языка С, не говоря уже о поддержке других языков программирования. Разработка собственного компилятора “с нуля", это самая большая ошибка, которую можно совершить. Результатом такой разработки, крайне долгой и дорогостоящей, будет компилятор с множеством ошибок, с множеством отклонений от стандарта языка, с плохой оптимизацией или вообще без неё, с поддержкой, может быть, только одного языка (например, С).</p>
<p><a href="/images/2015/10/DragonFull.png"><img class="alignnone size-medium wp-image-2153" alt="DragonFull" src="/assets/DragonFull-300x300.png" width="300" height="300" /></a></p>
<p><!--more-->Какой из этих двух open-source проектов выбрать в качестве основы для своего компилятора? GCC (GNU Compiler Collection) является более старым проектом, первый релиз которого состоялся в 1987 году, его автором является Ричард Столлман, известный деятель open-source движения [1]. Он поддерживает множество языков программирования: C, C++, Objective C, Fortran, Java, Ada, Go. Также существуют фронтенды для многих других языков программирования, не включенных в основную сборку. Компилятор GCC поддерживает большое количество процессорных архитектур и операционных систем, и является в настоящее время наиболее распространённым компилятором. Сам GCC написан на языке С.</p>
<p>LLVM гораздо "моложе", его первый релиз состоялся в 2003 году, он (а точнее, его фронтенд Clang) поддерживает языки программирования C, C++, Objective-C and Objective-C++, и также имеет фронтенды для языков Common Lisp, ActionScript, Ada, D, Fortran, OpenGL Shading Language, Go, Haskell, Java bytecode, Julia, Swift, Python, Ruby, Rust, Scala, C# и Lua. Он разработан в университете Иллинойса, в США, и является основным компилятором для разработки под операционную систему OS X. LLVM написан на языке С++ (С++11 для последних релизов) [2].</p>
<p>Какой из двух вариантов выбрать? Относительная "молодость" LLVM не является недостатком, он достаточно зрелый, чтобы в нём не было критических багов, и при этом он не несёт в себе огромного груза устаревших архитектурных решений, как GCC. Модульная структура компилятора позволяет использовать фронтенд LLVM-GCC, который обеспечивает полную поддержку стандартов GCC, при этом генерация кода целевой платформы будет осуществляться LLC (бэкенд LLVM). Также можно использовать Clang - оригинальный фронтенд LLVM.</p>
<p>Область применения LLVM не ограничивается разработкой компиляторов для новых процессоров, инфраструктура компиляторов LLVM также может применяться для разработки компиляторов новых языков программирования, новых алгоритмов оптимизации и специфических инструментов статического анализа программного кода (поиск ошибок, сбор статистики и т.п.).</p>
<p>Продолжение следует...</p>
]]></content>
  </entry>
  
</feed>
