<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Записная книжка разработчика]]></title>
  <link href="http://arktur04.github.io/atom.xml" rel="self"/>
  <link href="http://arktur04.github.io/"/>
  <updated>2016-03-23T21:33:52+05:00</updated>
  <id>http://arktur04.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Книга " the Architecture of Open Source Applications" под ред. Amy Brow]]></title>
    <link href="http://arktur04.github.io/blog/2016/03/23/knigha-the-architecture-of-open-source-applications-pod-ried-amy-brow/"/>
    <updated>2016-03-23T20:46:27+05:00</updated>
    <id>http://arktur04.github.io/blog/2016/03/23/knigha-the-architecture-of-open-source-applications-pod-ried-amy-brow</id>
    <content type="html"><![CDATA[<p>Прочитал главу 11 (LLVM, Chris Lattner), 15 стр, англ. язык.</p>

<p><a href="http://arktur04.github.io/images/2016/03/52401_original.jpg"><img title="КДПВ" src="http://arktur04.github.io/images/2016/03/52401_original_small.jpg" alt="" height="300" /></a></p>

<p>Книга “The Architecture of Open Source Applications” содержит краткое описание множества open-source продуктов, включая LLVM. Автор главы про LLVM даёт описание архитектуры системы, уделяя особое внимание преимуществам LLVM перед другими open-source компиляторами. Также рассматриваются различные необычные применения  LLVM, например, в системе обработки изображений.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Книга Suyog Sarda and Mayur Pandey "LLVM Essentials"]]></title>
    <link href="http://arktur04.github.io/blog/2016/03/23/knigha-suyog-sarda/"/>
    <updated>2016-03-23T20:37:00+05:00</updated>
    <id>http://arktur04.github.io/blog/2016/03/23/knigha-suyog-sarda</id>
    <content type="html"><![CDATA[<p>Прочитал книгу Suyog Sarda, Mayur Pandey “LLVM Essentials”, 166 стр., англ. язык.</p>

<p><a href="http://arktur04.github.io/images/2016/03/52027_original.jpg"><img title="КДПВ" src="http://arktur04.github.io/images/2016/03/52027_original_small.jpg" alt="" height="300" /></a></p>

<p>Ничего нового для себя не почерпнул, книга очень маленькая, но если вы решили начать изучение инфраструктуры компиляторов LLVM, то эта книга может дать некоторое начальное представление.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LLVM: компилятор своими руками. Введение]]></title>
    <link href="http://arktur04.github.io/blog/2016/02/28/llvm-kompiliator-svoimi-rukami-vviedieniie/"/>
    <updated>2016-02-28T22:02:44+05:00</updated>
    <id>http://arktur04.github.io/blog/2016/02/28/llvm-kompiliator-svoimi-rukami-vviedieniie</id>
    <content type="html"><![CDATA[<p>Опубликовал новый пост на Хабре: <a href="https://habrahabr.ru/post/277717/">ссылка</a>.</p>

<p><a href="http://arktur04.github.io/images/2016/02/84e79ac13efb48f19f490840a2339c27.jpeg"><img title="КДПВ" src="http://arktur04.github.io/images/2016/02/84e79ac13efb48f19f490840a2339c27_small.jpeg" alt="" height="300" /></a></p>

<p>В статье рассматривается применение инфраструктуры компиляторов LLVM для построения собственных решений на её основе.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Книга А. Ахо, М. С. Лам, Р. Сети, Д. Ульман "Компиляторы: принципы, технологии и инструментарий"]]></title>
    <link href="http://arktur04.github.io/blog/2016/02/28/knigha-a-akho/"/>
    <updated>2016-02-28T21:38:00+05:00</updated>
    <id>http://arktur04.github.io/blog/2016/02/28/knigha-a-akho</id>
    <content type="html"><![CDATA[<p>Легендарная “Книга дракона”, 2-е издание, русск. язык, 1184 стр.</p>

<p><a href="http://arktur04.github.io/images/2016/02/50379_original.png"><img title="Книга дракона" src="http://arktur04.github.io/images/2016/02/50379_small.png" alt="" height="300" /></a></p>

<p>В книге излагается теория построения компиляторов, начиная от разбора исходников (токенайзер, лексер, парсер), до оптимизации машинного кода.
Однако, в книге, несмотря на большой объём, я не нашёл некоторых важных вещей, например, нет ни слова про SSA-форму. А именно представление программы в SSA-форме может сделать очень эффективными многие алгоритмы оптимизации и генерации машинного кода.</p>

<p>А в целом полезная книга, конечно, классика IT-литературы, всё-таки.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Книга Gabriel S. Hjort Blindell "Survey on Instruction Selection"]]></title>
    <link href="http://arktur04.github.io/blog/2016/02/14/knigha-gabriel-s-hjort-blindell-survey-on-instruction-selection/"/>
    <updated>2016-02-14T22:06:06+05:00</updated>
    <id>http://arktur04.github.io/blog/2016/02/14/knigha-gabriel-s-hjort-blindell-survey-on-instruction-selection</id>
    <content type="html"><![CDATA[<p>Прочитал книгу Gabriel S. Hjort Blindell “Survey on Instruction Selection”, 139 стр, англ. язык.
Книга про то, как осуществляется одна из самых важных стадий работы компилятора, выбор инструкций. Рассмотрены различные подходы и алгоритмы решения этой задачи, от первых компиляторов 1950-х годов до современных.</p>

<p><a href="http://arktur04.github.io/images/2016/02/49450_600.png"><img title="Creating an LLVM Backend for the Cpu0 Architecture" src="http://arktur04.github.io/images/2016/02/49450_600-small.png" alt="" height="300" /></a></p>

<p>Немного написано и про алгоритм, используемый в LLVM. К сожалению, ничего особенно нового эта информация мне не дала. Этот участок компилятора весьма сложен, и возможности для ручного вмешательства в его работу очень ограничены (хотя и существуют).</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Книга Steven W. Smith "the Scientist and Engineer’s Guide to Digital Signal Processing"]]></title>
    <link href="http://arktur04.github.io/blog/2016/01/10/knigha-steven-w-smith-the-scientist-and-engineers-guide-to-digital-signal-processing/"/>
    <updated>2016-01-10T20:51:57+05:00</updated>
    <id>http://arktur04.github.io/blog/2016/01/10/knigha-steven-w-smith-the-scientist-and-engineers-guide-to-digital-signal-processing</id>
    <content type="html"><![CDATA[<p>Steven W. Smith “The Scientist and Engineer’s Guide to Digital Signal Processing”, 626 стр, англ. язык. Книга легально и бесплатно доступна для скачивания с сайта Analog Devices.
Я читал эту книгу когда-то давно, но отдельными главами, а сейчас решил освежить в памяти ключевые моменты DSP.</p>

<p><a href="http://arktur04.github.io/images/2016/01/47958_600.gif"><img title="The Scientist and Engineer’s Guide to Digital Signal Processing" src="http://arktur04.github.io/images/2016/01/47958_600_small.png" alt="" height="300" /></a></p>

<p>Книга достаточно простая, и обходится абсолютным минимумом математических формул. Автор делает основной упор на то, чтобы читатель наглядно представлял себе, как связаны между собой различные преобразования, используемые в DSP: фильтрация, ДПФ, свёртка и т. п.
В книге приведены основные алгоритмы DSP: фильтры, КИХ и БИХ, ДПФ прямое и обратное и некоторые другие. Таким образом, вы можете воспользоваться готовыми программами, переписать их на С или на ассемблере и не вдаваться глубоко в математику.
Если интересна именно математика, лежащая в основе DSP, нужно читать Оппенгейма-Шафера.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Книга Chen Chung-Shu "Creating an LLVM Backend for the Cpu0 Architecture"]]></title>
    <link href="http://arktur04.github.io/blog/2016/01/04/knigha-chen-chung-shu-creating-an-llvm-backend-for-the-cpu0-architecture/"/>
    <updated>2016-01-04T20:17:43+05:00</updated>
    <id>http://arktur04.github.io/blog/2016/01/04/knigha-chen-chung-shu-creating-an-llvm-backend-for-the-cpu0-architecture</id>
    <content type="html"><![CDATA[<p>Прочитал книгу Chen Chung-Shu “Creating an LLVM Backend for the Cpu0 Architecture”, 575 стр., англ. язык.
Книга по LLVM, единственная в своём роде книга, детально описывающая процесс разработки бэкенда.</p>

<p><a href="http://arktur04.github.io/images/2016/01/line-tile.png"><img title="Creating an LLVM Backend for the Cpu0 Architecture" src="http://arktur04.github.io/images/2016/01/line-tile_small.png" alt="" height="300" /></a></p>

<p>Я читал эту книгу ранее, но автор непрерывно вносит исправления и дополнения в текст (эта книга существует только в онлайновом виде), поэтому я решил перечитать всё полностью, с начала до конца, самый свежий вариант. Сейчас я могу сказать, что читал по LLVM всё, что опубликовано, и что имеет хотя бы немного существенное значение (можно также найти огромное количество статей в духе “мы разработали компилятор для нашего процессора, это круто”. Их я обычно не читаю). Источников по LLVM очень мало, печатных книг всего две, например.</p>

<p>Проблема ещё и в том, что все процессоры разные, и нельзя просто скопировать исходник одного бэкенда, подправить там пару строк и получить другой. Они настолько различны, что вряд ли вы вообще найдёте в двух разных бэкендах похожие куски кода. Поэтому чтение этой книги не заменит вам собственного опыта.
Желающим разработать свой компилятор, я могу посоветовать следующее:
не бояться разбираться в существующем коде, как бэкендов, так и Core Library.
не бояться экспериментировать и писать с нуля собственные алгоритмы оптимизаций.
не пытаться изобрести велосипед. Если нужные функции есть в Core Library, их необходимо изучить и использовать. Если, напротив, каких-то функций нет ни в Core Library, ни в других бэкендах, значит, скорее всего, вы хотите странного, и, скорее всего, на самом деле это вам не нужно. Хотя могут быть исключения из этого правила.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Книга Andrew Moore "FPGA for Dummies"]]></title>
    <link href="http://arktur04.github.io/blog/2015/12/16/knigha-fpga-for-dummies/"/>
    <updated>2015-12-16T21:41:38+05:00</updated>
    <id>http://arktur04.github.io/blog/2015/12/16/knigha-fpga-for-dummies</id>
    <content type="html"><![CDATA[<p>Прочитал книгу Andrew Moore “FPGA for dummies”, 44 стр., англ. язык. Книжка совсем простая, конечно, и объясняет совсем базовые вещи, типа, что такое FPGA и зачем они нужны.</p>

<p><a href="http://arktur04.github.io/images/2015/12/FPGAs_dummies_full.jpg"><img title="FPGA for dummies" src="http://arktur04.github.io/images/2015/12/FPGAs_dummies_small.png" alt="" height="300" /></a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Книга Вирт Н. "Построение компиляторов"]]></title>
    <link href="http://arktur04.github.io/blog/2015/12/16/knigha-virt-kompiliatory/"/>
    <updated>2015-12-16T20:00:22+05:00</updated>
    <id>http://arktur04.github.io/blog/2015/12/16/knigha-virt-kompiliatory</id>
    <content type="html"><![CDATA[<p>Прочитал книгу Вирт Н. “Построение компиляторов”, 192 стр., русск. язык.</p>

<p><a href="http://arktur04.github.io/images/2015/12/vurt_full.jpg"><img title="Qt5.3. Профессиональное программирование на С++" src="http://arktur04.github.io/images/2015/12/vurt_small.jpg" alt="" height="300" /></a></p>

<p>Книга может служить хорошим введением в тему, хотя классическим трудом по компиляторам является <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D1%8B:_%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B,_%D1%82%D0%B5%D1%85%D0%BD%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D0%B8_%D0%B8_%D0%B8%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D1%8B">“книга дракона”</a>.
Вирт в настоящее время несколько утратил былую славу, во многом из-за странного языка Оберон, который очень сильно уступает современным языкам. Все примеры в книге на Обероне. К счастью, он практически неотличим от Паскаля, с которого я когда-то начинал. Как краткое введение книгу читать можно.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Книга М. Шлее «Qt5.3. Профессиональное программирование на С++»]]></title>
    <link href="http://arktur04.github.io/blog/2015/12/16/knigha-qt/"/>
    <updated>2015-12-16T18:15:46+05:00</updated>
    <id>http://arktur04.github.io/blog/2015/12/16/knigha-qt</id>
    <content type="html"><![CDATA[<p>Прочитал книгу М. Шлее «Qt5.3. Профессиональное программирование на С++», 928 стр., и проработал (по мере возможности) все примеры кода.</p>

<p><a href="http://arktur04.github.io/images/2015/12/qt5.3_full.jpg"><img title="Qt5.3. Профессиональное программирование на С++" src="http://arktur04.github.io/images/2015/12/qt5.3_small.jpg" alt="" height="300" /></a></p>

<p>Раньше я читал Шлее “Qt 4.5”, новая книга стала больше, но в целом принципы работы Qt остались те же. Возможности системы описаны достаточно подробно, но во второй половине книги в коде попадаются странные ошибки.</p>

<p>Я видел в сети критические мнения о книге, в которых приводился, в частности, аргумент, что документация по Qt настолько хороша, что в книге нет нужды. Лично я считаю, что книга всё равно нужна, документация не заменяет учебника. Учебник можно прочитать в начале знакомства с продуктом, и получить хотя бы общее представление обо всех его ключевых особенностях, а конкретные вопросы уточнять в процессе работы, обращаясь к фирменной документации.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Проект видеоадаптера. Часть 3]]></title>
    <link href="http://arktur04.github.io/blog/2015/11/23/%25d0%25bf%25d1%2580%25d0%25be%25d0%25b5%25d0%25ba%25d1%2582-%25d0%25b2%25d0%25b8%25d0%25b4%25d0%25b5%25d0%25be%25d0%25b0%25d0%25b4%25d0%25b0%25d0%25bf%25d1%2582%25d0%25b5%25d1%2580%25d0%25b0-%25d1%2587%25d0%25b0%25d1%2581%25d1%2582%25d1%258c-3/"/>
    <updated>2015-11-23T21:00:45+05:00</updated>
    <id>http://arktur04.github.io/blog/2015/11/23/%d0%bf%d1%80%d0%be%d0%b5%d0%ba%d1%82-%d0%b2%d0%b8%d0%b4%d0%b5%d0%be%d0%b0%d0%b4%d0%b0%d0%bf%d1%82%d0%b5%d1%80%d0%b0-%d1%87%d0%b0%d1%81%d1%82%d1%8c-3</id>
    <content type="html"><![CDATA[<p>Продолжение. <a href="http://arktur04.github.io/blog/2015/11/05/vga-%25d0%25b0%25d0%25b4%25d0%25b0%25d0%25bf%25d1%2582%25d0%25b5%25d1%2580-%25d0%25bd%25d0%25b0-fpga/">Часть 2.</a></p>
<p>Структурная схема видеоадаптера приведена на рис. 1 (кликабельно)</p>
<p><a href="http://arktur04.github.io/images/2015/11/vga-card-big.jpg"><img class="alignnone size-medium wp-image-2175" alt="vga-card-big" src="http://arktur04.github.io/assets/vga-card-big-300x214.jpg" width="300" height="214" /></a></p>
<p>&nbsp;</p>
<p>Рис. 1. Структурная схема видеоадаптера.</p>
<p>&nbsp;</p>
<p>Пояснения к схеме:</p>
<p>В первой версии видеоадаптер будет иметь только текстовый режим EGA, 80 * 25 символов 8 * 14 пикселов каждый символ. Таким образом, экранное разрешение составит 8 * 80 = 640 пикселов по горизонтали и 14 * 25 = 350 пикселов по вертикали. Частота пикселов в этом режиме составляет, по стандарту 25,175 МГц, фактическая частота будет 25 МГц, в связи с тем, что частота тактирования ПЛИС составляет 50 МГц. При этом на любом мониторе происходит нормальная синхронизация.</p>
<p><!--more--></p>
<p>Для аналогичного тектового видеорежима VGA разрешение составляет 720 * 400 пикселей, т.к. символы имеют размер 9*16 пикселей. Частота пикселов при этом должна быть 28,322 МГц, и нормальная синхронизация с частотой 25 МГц невозможна. Можно получить близкую частоту с помощью PLL, но тогда потребуются блоки для асинхронного сопряжения видеоадаптера с микропроцессорной частью проекта, т.к. микропроцессорная часть будет тактироваться частотой 50 МГц. Это будет следующим этапом проекта, пока вся схема будет тактироваться от 50 МГц.</p>
<p>Графические режимы тоже будут позже, пока будет реализован максимально простой вариант.</p>
<p>Некоторые пояснения по схеме:</p>
<p><strong>sync_gen</strong> - генератор синхроимпульсов. Имеет выходы <em>h_coord_reg</em> и <em>v_coord_reg</em>, соответственно, текущие координаты пиксела по горизонтали и вертикали. <em>data_en</em> - сигнал разрешения данных. Этот же сигнал используется для "гашения" выходов ЦАП. <em>hsync_reg</em> и<em> vsync_reg</em> - сигналы горизонтальной и вертикальной синхронизации.</p>
<p>Так как вся схема состоит из нескольких модулей, включенных последовательно, прохождение сигнала по ним занимает несколько тактов. В связи с этим сигналы <em>data_en, <em>hsync_reg</em> </em>и <em><em>vsync_reg</em></em> также должны быть задержаны, чтобы приходить на выход синхронно с сигналами соответствующего пиксела.</p>
<p><strong>addr_decoder</strong> - так как видеоадаптер будет использовать в качестве видеопамяти внешнюю sdram, которая будет использоваться совместно с основным микропроцессором, <strong> </strong>необходимо иметь небольшую буферную память, чтобы избежать проблем, связанных с временем доступа к внешней памяти. Этот буфер будет двойным, пока идёт выборка из одного блока памяти, в другой загружаются данные из внешней памяти, затем они меняются местами. каждый блок памяти будет иметь размер 256*16 бит. 16-и битный выход позволит получит сразу и ком символа, и информацию об его цвете. Модуль <strong>addr_decoder</strong> вырабатывает текущий адрес в буфере <em>buffer_addr_reg</em>, исходя из текущей координаты пиксела и смещения буфера (т.е. адреса, который отображается на начало буфера). Также этот модуль вырабатывает сигналы <em>hmod_reg</em> и <em>vmod_reg</em>, которые являются координатой пиксела в текущем знакоместе (т.е. абсолютной координатой по модулю 8 и 14 соответственно).</p>
<p><strong>buf_mem </strong> - буфер памяти, см. предыдущий абзац.</p>
<p><strong>mem_controlle</strong>r - контроллер памяти. Должен обеспечивать подкачку содержимого буфера из внешней SDRAM. Также, в будущем, будет обеспечивать асинхронные взаимодействия видеоадаптера и основной части, при их работе на разной тактовой частоте.</p>
<p><strong>mode_controller</strong> - контроллер видеорежима. Пока видеоадаптер будет иметь только один текстовый режим, но в будущем контроллер должен будет обесипечивать установку всех остальных модулей в состояние, соответствующее текущему видеорежиму. Также модуль выделяет код символа (<em>char_code_reg</em>), цвет символа (<em>char_color_reg</em>), цвет фона (<em>back_color_reg</em>) и признак мигания <em>blink</em>.</p>
<p><strong>char_gen</strong> - знакогенератор. В данной версии представляет собой ПЗУ с таблицей символов EGA (8*14), но впоследствии будет содержать символы VGA (9*16) и символы 8*8, а также программируемые пользователем символы. На его вход поступает код символа (<em>char_code</em>) и номер строки символа (<em>vmod</em>), на выходе появляется строка текущего знакоместа (<em>char_data_reg</em>).</p>
<p><strong>pixel_data_decode</strong>r - на основании сигналов <em>char_data, hmod, char_color, back_color, blink</em> определяет цвет текущего пиксела в палитре.</p>
<p><strong>palette</strong> - регистры палитры. В данной версии представляет собой ПЗУ, в дальнейшем будет возможность его изменения пользовательской программой.</p>
<p>Пока это черновик схемы, она будет дорабатываться и изменяться по мере продвижения проекта.</p>
<p>&nbsp;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Книга "Software Defined Radio Handbook", Rodger Hosking]]></title>
    <link href="http://arktur04.github.io/blog/2015/11/16/%25d0%25ba%25d0%25bd%25d0%25b8%25d0%25b3%25d0%25b0-software-defined-radio-handbook-rodger-hosking/"/>
    <updated>2015-11-16T19:03:04+05:00</updated>
    <id>http://arktur04.github.io/blog/2015/11/16/%d0%ba%d0%bd%d0%b8%d0%b3%d0%b0-software-defined-radio-handbook-rodger-hosking</id>
    <content type="html"><![CDATA[<p>Прочитал книгу "Software Defined Radio Handbook", 75 стр, англ. язык.</p>
<p><a href="http://arktur04.github.io/images/2015/11/Pentek-SDR-Handbook.jpg"><img class="alignnone size-medium wp-image-2171" alt="Pentek-SDR-Handbook" src="http://arktur04.github.io/assets/Pentek-SDR-Handbook-221x300.jpg" width="221" height="300" /></a></p>
<p>Собственно, название вводит в заблуждение. Это не столько handbook, сколько рекламный проспект фирмы Pentek, которая выпускает отладочные платы для SDR. Платы, например, такие: 2 канала АЦП по 3,6 ГГц и 4 канала по 1,8 ГГц + Virtex 6. Это для меня несколько неактуально. А теория SDR изложена очень поверхностно, хочется чего-то глубокого.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Проект видеоадаптера. Часть 2]]></title>
    <link href="http://arktur04.github.io/blog/2015/11/05/vga-%25d0%25b0%25d0%25b4%25d0%25b0%25d0%25bf%25d1%2582%25d0%25b5%25d1%2580-%25d0%25bd%25d0%25b0-fpga/"/>
    <updated>2015-11-05T21:38:06+05:00</updated>
    <id>http://arktur04.github.io/blog/2015/11/05/vga-%d0%b0%d0%b4%d0%b0%d0%bf%d1%82%d0%b5%d1%80-%d0%bd%d0%b0-fpga</id>
    <content type="html"><![CDATA[<p>Продолжение. <a title="Начало" href="http://arktur04.github.io/blog/2015/05/13/%25d0%25bf%25d1%2580%25d0%25be%25d0%25b5%25d0%25ba%25d1%2582-%25d0%25b2%25d0%25b8%25d0%25b4%25d0%25b5%25d0%25be%25d0%25b0%25d0%25b4%25d0%25b0%25d0%25bf%25d1%2582%25d0%25b5%25d1%2580%25d0%25b0-%25d1%2587%25d0%25b0%25d1%2581%25d1%2582%25d1%258c-1/">Начало</a>.</p>
<p>Проект видеоадаптера переделан под использование видео ЦАП ADV7123. Схема подключения приведена на рисунке:</p>
<p><a href="http://arktur04.github.io/images/2015/11/VGA_DAC.jpg"><img class="alignnone size-medium wp-image-2168" alt="VGA_DAC" src="http://arktur04.github.io/assets/VGA_DAC-300x190.jpg" width="300" height="190" /></a></p>
<p>(по клику откроется полный размер).</p>
<p>Код проекта приведён на гитхабе (<a href="https://github.com/arktur04/VideoCard">ссылка</a>). Это тестовый код, который выводит на монитор поле разноцветных квадратов.</p>
<p>По сравнению с предыдущей версией, в которой использовался резистивный ЦАП, увеличена разрядность с 2-х до 8-и бит на цвет, и существенно улучшилось качество изображения.</p>
<p>Фото тестовой картинки:</p>
<p><a href="http://arktur04.github.io/images/2015/11/pic1.jpg"><img class="alignnone size-medium wp-image-2166" alt="pic" src="http://arktur04.github.io/assets/pic1-300x189.jpg" width="300" height="189" /></a></p>
<p>&nbsp;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Драйвер для Linux: первый шаг]]></title>
    <link href="http://arktur04.github.io/blog/2015/10/02/%25d0%25b4%25d1%2580%25d0%25b0%25d0%25b9%25d0%25b2%25d0%25b5%25d1%2580-%25d0%25b4%25d0%25bb%25d1%258f-linux-%25d0%25bf%25d0%25b5%25d1%2580%25d0%25b2%25d1%258b%25d0%25b9-%25d1%2588%25d0%25b0%25d0%25b3/"/>
    <updated>2015-10-02T22:11:34+05:00</updated>
    <id>http://arktur04.github.io/blog/2015/10/02/%d0%b4%d1%80%d0%b0%d0%b9%d0%b2%d0%b5%d1%80-%d0%b4%d0%bb%d1%8f-linux-%d0%bf%d0%b5%d1%80%d0%b2%d1%8b%d0%b9-%d1%88%d0%b0%d0%b3</id>
    <content type="html"><![CDATA[<p>Продолжаю эксперименты с Altera Cyclone V. На этот раз объектом эксперимента стал драйвер для той прошивки FPGA, про которую я писал ранее. Сама прошивка простейшая: она просто мигает светодиодами с частотой, которую можно задавать программно. В прошлом посте на эту тему я сделал управление частотой мигания из обычной (user-space) программы, которая получает доступ к физической памяти через функции open("/dev/mem") и mmap().<br />
Однако такой путь считается "hacky and unsafe". Поэтому следующим логичным шагом должно стать написание драйвера.</p>
<p><a href="http://arktur04.github.io/images/2015/10/Tux-linux-and-ARM-multiplatform-support.jpg"><img class="alignnone size-full wp-image-2147" alt="Tux-linux-and-ARM-multiplatform-support" src="http://arktur04.github.io/assets/Tux-linux-and-ARM-multiplatform-support.jpg" width="672" height="370" /></a></p>
<p>Я воспользовался готовым исходником драйвера (<a href="https://github.com/zhemao/sockit_test/tree/master/software/blinker">ссылка</a>) за авторством Howard Mao (он на самом деле не Howard, а Zhe Hao Mao). Конечно, для того, чтобы разобраться в работе кода, почитал отдельные главы книги Linux Device Drivers (есть русский перевод).</p>
<p>Для компиляции пришлось вытаскивать архив Arrow SocKit 13.1 GSRD Linux отсюда: <a href="http://releases.rocketboards.org/release/2013.11/gsrd/src">http://releases.rocketboards.org/release/2013.11/gsrd/src</a>, файл linux-socfpga-gsrd-13.1-src.bsx. Объем архива около 1.1 Гб, но сервер очень медленный, качается несколько часов. Честно говоря, я впервые увидел файл с расширением bsx, оказалось, что это самораспаковывающийся архив. Просто запускаем его и он разворачивается в указанную папку. В ней в папке sources находится файл linux-socfpga.tgz. Его тоже нужно распаковать, естественно. Это и есть как таковое ядро системы, которое нужно указывать при компиляции драйвера.</p>
<p>Однако всё не так просто. После компиляции записываем скомпилированный драйвер blinker.ko на SD-карту, после загрузки Linux пишем<strong> insmod blinker.ko</strong> и получаем следующее: "<em>blinker: version magic '3.9.0-00161-ged01b8c SMP mod_unload ARMv7 p2v8 ' should be '3.9.0 SMP mod_unload ARMv7 p2v8'</em>". Не совпали волшебные номерки. Причем версия одна и та же, просто зачем-то к ней приделан какой-то добавочный номер.</p>
<p>Решений может быть три: 1. Скомпилировать Linux именно из этого скачанного исходника (очень неохота) или 2. Подправить номер в исходниках ядра Linux. 3. Использовать команду modprobe с ключом -f, который заставляет систему игнорировать "волшебные цифры".  Однако этот способ почему-то не заработал.<br />
Итак, способ номер 2, подправить номер в исходнике ядра. Данный номер записан в файле /include/generated/utsrelease.h. Исправляем то, что там было, на "3.9.0", и перекомпилируем драйвер. На всякий случай смотрим hex-редактором файл blinker.ko, чтобы убедиться, что волшебные циферки такие, как нужно. Снова записываем драйвер на SD-карту, запускаем insmod, всё прошло гладко. Теперь можно проверить работу драйвера, посылая ему числа от 1 до 15 для управления частотой миганий: echo 1 &gt; blinker - мигает быстро, echo 15 &gt; blinker - мигает медленно. Пока всё. Немного, но путь в тысячу ли начинается с одного шага.</p>
<p>Эксперименты продолжаются.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Управление FPGA из программы]]></title>
    <link href="http://arktur04.github.io/blog/2015/09/23/%25d1%2583%25d0%25bf%25d1%2580%25d0%25b0%25d0%25b2%25d0%25bb%25d0%25b5%25d0%25bd%25d0%25b8%25d0%25b5-fpga-%25d0%25b8%25d0%25b7-%25d0%25bf%25d1%2580%25d0%25be%25d0%25b3%25d1%2580%25d0%25b0%25d0%25bc%25d0%25bc%25d1%258b/"/>
    <updated>2015-09-23T20:51:35+05:00</updated>
    <id>http://arktur04.github.io/blog/2015/09/23/%d1%83%d0%bf%d1%80%d0%b0%d0%b2%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5-fpga-%d0%b8%d0%b7-%d0%bf%d1%80%d0%be%d0%b3%d1%80%d0%b0%d0%bc%d0%bc%d1%8b</id>
    <content type="html"><![CDATA[<p>Приведённый ниже код писал не я, он взят отсюда:<a href="https://zhehaomao.com/blog/fpga/2013/12/27/sockit-3.html"> https://zhehaomao.com/blog/fpga/2013/12/27/sockit-3.html</a>, но я решил оставить его здесь, т.к. он пригодится для дальнейших экспериментов.</p>
<p>Напоминаю, что данная программа работает в ОС Linux GSRD на SoC Altera Cyclone V (ядро ARM Cortex A9). Компилятор Linaro GCC, берём здесь: <a href="http://releases.linaro.org/latest/components/toolchain/binaries/4.8/arm-linux-gnueabihf/">http://releases.linaro.org/latest/components/toolchain/binaries/4.8/arm-linux-gnueabihf/</a></p>
<pre lang="c" line="1">#include <sys/mman.h>;
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdint.h>

#define PAGE_SIZE 4096
#define LWHPS2FPGA_BRIDGE_BASE 0xff200000
#define BLINK_OFFSET 0x0

volatile unsigned char *blink_mem;
void *bridge_map;

int main(int argc, char *argv[])
{
	int fd, ret = EXIT_FAILURE;
	unsigned char value;
	off_t blink_base = LWHPS2FPGA_BRIDGE_BASE;

	if (argc < 2) {
		fprintf(stderr, "Usage: %s number\n", argv[0]);
		exit(EXIT_FAILURE);
	}

	/* check the bounds of the value being set */
	value = atoi(argv[1]);
	if (value < 1 || value > 15) {
		fprintf(stderr, "Invalid delay setting."
				"Delay must be between 1 and 15, inclusive.\n");
		exit(EXIT_FAILURE);
	}

	/* open the memory device file */
	fd = open("/dev/mem", O_RDWR|O_SYNC);
	if (fd < 0) {
		perror("open");
		exit(EXIT_FAILURE);
	}

	/* map the LWHPS2FPGA bridge into process memory */
	bridge_map = mmap(NULL, PAGE_SIZE, PROT_WRITE, MAP_SHARED,
				fd, blink_base);
	if (bridge_map == MAP_FAILED) {
		perror("mmap");
		goto cleanup;
	}

	/* get the delay_ctrl peripheral's base address */
	blink_mem = (unsigned char *) (bridge_map + BLINK_OFFSET);

	/* write the value */
	*blink_mem = value;

	if (munmap(bridge_map, PAGE_SIZE) < 0) {
		perror("munmap");
		goto cleanup;
	}

	ret = 0;

cleanup:
	close(fd);
	return ret;
}</stdint.h></unistd.h></stdlib.h></stdio.h></fcntl.h></pre>
<p>Программа управляет частотой мигания светодиода, сам делитель частоты расположен в FPGA, частота задаётся регистром.</p>
<p><!--more--></p>
<p>Если убрать все строки, отвечающие за обработку ошибок, то остаётся это:</p>
<pre lang="c" line="1">bridge_map = mmap(NULL, PAGE_SIZE, PROT_WRITE, MAP_SHARED,
			fd, blink_base);
blink_mem = (unsigned char *) (bridge_map + BLINK_OFFSET);
*blink_mem = value;</pre>
<p>Здесь мы отображаем функцией mmap страницу памяти моста lwhps2fpga в пространство памяти процесса.</p>
<pre lang="bash" line="1"># enable the lwhps2fpga bridge
echo 1 > /sys/class/fpga-bridge/lwhps2fpga/enable
# make it blink fast
./blinker 1
# make it blink slow
./blinker 15</pre>
<p>Продолжение следует.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Книга Mayur Pandey, Suyog Sarda "LLVM Cookbook"]]></title>
    <link href="http://arktur04.github.io/blog/2015/09/11/%25d0%25ba%25d0%25bd%25d0%25b8%25d0%25b3%25d0%25b0-mayur-pandey-suyog-sarda-llvm-cookbook/"/>
    <updated>2015-09-11T17:18:08+05:00</updated>
    <id>http://arktur04.github.io/blog/2015/09/11/%d0%ba%d0%bd%d0%b8%d0%b3%d0%b0-mayur-pandey-suyog-sarda-llvm-cookbook</id>
    <content type="html"><![CDATA[<p>Прочитал книгу Mayur Pandey, Suyog Sarda "LLVM Cookbook", 284 стр, англ. язык.<br />
Хорошая книга, описывает много интересных вещей об архитектуре и внутреннем устройстве инфраструктуры компиляторов LLVM.<br />
Она дополняет другую книгу, "Getting Started with LLVM Core Libraries", про которую я уже <a href="http://arktur04.github.io/blog/2014/12/02/%25d0%25ba%25d0%25bd%25d0%25b8%25d0%25b3%25d0%25b0-bruno-cardoso-lopes-getting-started-with-llvm-core-libraries/">писал</a>. Кстати,  Getting Started with LLVM Core Libraries переведена на русский язык и сейчас есть в продаже (я читал в оригинале).</p>
<p><a href="http://arktur04.github.io/images/2015/09/5981OS_LLVM-Cookbook.jpg"><img class="alignnone size-medium wp-image-2137" alt="5981OS_LLVM Cookbook" src="http://arktur04.github.io/assets/5981OS_LLVM-Cookbook-243x300.jpg" width="243" height="300" /></a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Книга Р. Лав «Разработка ядра Linux» (второе издание)]]></title>
    <link href="http://arktur04.github.io/blog/2015/09/05/%25d0%25ba%25d0%25bd%25d0%25b8%25d0%25b3%25d0%25b0-%25d1%2580-%25d0%25bb%25d0%25b0%25d0%25b2-%25d1%2580%25d0%25b0%25d0%25b7%25d1%2580%25d0%25b0%25d0%25b1%25d0%25be%25d1%2582%25d0%25ba%25d0%25b0-%25d1%258f%25d0%25b4%25d1%2580%25d0%25b0-linux-%25d0%25b2%25d1%2582%25d0%25be%25d1%2580%25d0%25be%25d0%25b5/"/>
    <updated>2015-09-05T17:08:22+05:00</updated>
    <id>http://arktur04.github.io/blog/2015/09/05/%d0%ba%d0%bd%d0%b8%d0%b3%d0%b0-%d1%80-%d0%bb%d0%b0%d0%b2-%d1%80%d0%b0%d0%b7%d1%80%d0%b0%d0%b1%d0%be%d1%82%d0%ba%d0%b0-%d1%8f%d0%b4%d1%80%d0%b0-linux-%d0%b2%d1%82%d0%be%d1%80%d0%be%d0%b5</id>
    <content type="html"><![CDATA[<p>Прочитал книгу «Разработка ядра Linux», автор Р. Лав.</p>
<p>В книге подробно описывается внутренняя структура ядра Linux.</p>
<p><a href="http://arktur04.github.io/images/2015/09/346326_razrabotka_yadra_linux.jpg"><img class="alignnone  wp-image-2122" alt="346326_razrabotka_yadra_linux" src="http://arktur04.github.io/assets/346326_razrabotka_yadra_linux.jpg" width="434" /></a></p>
<p>&nbsp;</p>
<p>Книга, без сомнения, достойна прочтения, если вы занимаетесь разработкой модулей ядра.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Книга Р. Лав "Linux. Системное программирование"]]></title>
    <link href="http://arktur04.github.io/blog/2015/08/25/%25d0%25ba%25d0%25bd%25d0%25b8%25d0%25b3%25d0%25b0-%25d1%2580-%25d0%25bb%25d0%25b0%25d0%25b2-linux-%25d1%2581%25d0%25b8%25d1%2581%25d1%2582%25d0%25b5%25d0%25bc%25d0%25bd%25d0%25be%25d0%25b5-%25d0%25bf%25d1%2580%25d0%25be%25d0%25b3%25d1%2580%25d0%25b0%25d0%25bc%25d0%25bc%25d0%25b8%25d1%2580%25d0%25be%25d0%25b2%25d0%25b0/"/>
    <updated>2015-08-25T15:50:49+05:00</updated>
    <id>http://arktur04.github.io/blog/2015/08/25/%d0%ba%d0%bd%d0%b8%d0%b3%d0%b0-%d1%80-%d0%bb%d0%b0%d0%b2-linux-%d1%81%d0%b8%d1%81%d1%82%d0%b5%d0%bc%d0%bd%d0%be%d0%b5-%d0%bf%d1%80%d0%be%d0%b3%d1%80%d0%b0%d0%bc%d0%bc%d0%b8%d1%80%d0%be%d0%b2%d0%b0</id>
    <content type="html"><![CDATA[<p>Прочитал книгу Р. Лав "Linux. Системное программирование".<br />
В книге описывается ряд системных вызовов для работы с файлами, процессами, временем, сигналами и распределением памяти. Приводятся сведения о работе этих вызовов по стандарту POSIX и по их реализации в ядре Linux.</p>
<p><a href="http://arktur04.github.io/images/2015/08/3a56606f29e71f3a51b8c5fdd1d.jpg"><img class="alignnone size-full wp-image-2118" alt="3a56606f29e71f3a51b8c5fdd1d" src="http://arktur04.github.io/assets/3a56606f29e71f3a51b8c5fdd1d.jpg" width="407" height="600" /></a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Прошиваем FPGA в Run-time]]></title>
    <link href="http://arktur04.github.io/blog/2015/08/21/%25d0%25bf%25d1%2580%25d0%25be%25d1%2588%25d0%25b8%25d0%25b2%25d0%25b0%25d0%25b5%25d0%25bc-fpga-%25d0%25b2-run-time/"/>
    <updated>2015-08-21T22:22:04+05:00</updated>
    <id>http://arktur04.github.io/blog/2015/08/21/%d0%bf%d1%80%d0%be%d1%88%d0%b8%d0%b2%d0%b0%d0%b5%d0%bc-fpga-%d0%b2-run-time</id>
    <content type="html"><![CDATA[<p>В общем, ничего сложного.<br />
Для того, чтобы заливать прошивку в FPGA из процессорного ядра, нужно сделать следующее:<br />
1. Подготовить файл rbf, это и есть файл прошивки. Он делается из файла sof с помощью утилиты Quartus:</p>
<p>quartus_cpf -c output_files/sockit_test.sof output_files/sockit_test.rbf</p>
<p>Положить этот файл в основной раздел SD-карты, например, в корень.</p>
<p>2. После загрузки linux, отключить мосты между FPGA и HPS (HPS - это процессорное ядро):</p>
<p>echo 0 &gt; /sys/class/fpga-bridge/fpga2hps/enable<br />
echo 0 &gt; /sys/class/fpga-bridge/hps2fpga/enable<br />
echo 0 &gt; /sys/class/fpga-bridge/lwhps2fpga/enable</p>
<p>И заливаем файл в FPGA:</p>
<p>dd if=/sockit_test.rbf of=/dev/fpga0 bs=1M</p>
<p>Собственно, всё. Мосты можно включить обратно, если нужно:</p>
<p>echo 1 &gt; /sys/class/fpga-bridge/fpga2hps/enable<br />
echo 1 &gt; /sys/class/fpga-bridge/hps2fpga/enable<br />
echo 1 &gt; /sys/class/fpga-bridge/lwhps2fpga/enable</p>
<p>Разумеется, всё это можно делать скриптом.<br />
Пишем файл gsrd_init.sh:</p>
<pre lang="bash" line="1">#!/bin/sh

echo 0 > /sys/class/fpga-bridge/fpga2hps/enable
echo 0 > /sys/class/fpga-bridge/hps2fpga/enable
echo 0 > /sys/class/fpga-bridge/lwhps2fpga/enable
dd if=/sockit_test.rbf of=/dev/fpga0 bs=1M
echo 1 > /sys/class/fpga-bridge/fpga2hps/enable
echo 1 > /sys/class/fpga-bridge/hps2fpga/enable
echo 1 > /sys/class/fpga-bridge/lwhps2fpga/enable
</pre>
<p>Кладём его в /etc/init.d. Теперь после загрузки Linux прошивка FPGA будет загружаться автоматически.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Книга B. Stroustrup "a Tour of C++"]]></title>
    <link href="http://arktur04.github.io/blog/2015/08/14/%25d0%25ba%25d0%25bd%25d0%25b8%25d0%25b3%25d0%25b0-b-stroustrup-a-tour-of-c/"/>
    <updated>2015-08-14T15:52:56+05:00</updated>
    <id>http://arktur04.github.io/blog/2015/08/14/%d0%ba%d0%bd%d0%b8%d0%b3%d0%b0-b-stroustrup-a-tour-of-c</id>
    <content type="html"><![CDATA[<p>Прочитал книгу B. Stroustrup "A Tour of C++", Addison-Wesley, 2013, 180 стр, англ. язык.</p>
<p><a href="http://arktur04.github.io/images/2015/08/51xVLzxX4vL._SX370_BO1204203200_.jpg"><img class="alignnone size-full wp-image-2111" alt="51xVLzxX4vL._SX370_BO1,204,203,200_" src="http://arktur04.github.io/assets/51xVLzxX4vL._SX370_BO1204203200_.jpg" width="372" height="499" /></a></p>
<p>Книга не является ни учебником по С++, ни полным справочником по С++, это именно "тур", обзор основных возможностей С++11, причем и тех, которые были в стандарте С++98, и новых. Рекомендую прочитать тем, кто знает язык, но хочет усовершенствовать эти знания.</p>
]]></content>
  </entry>
  
</feed>
